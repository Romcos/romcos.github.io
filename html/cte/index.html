<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Labyrinthe + Multi Agents (Random DFS / CTE)</title>
  <!-- Copyright (c) 2026 Romain — see LICENSE for terms. -->

<!-- 
  ______________________ CSS ____________________
  Complete CSS Stylying 
    body, button, select: refer to html elements
    .layout, .controls etc.: are class selectors
  __________________________________________
-->
  <style>
    body { display:flex; flex-direction:column; align-items:center; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 16px; }
    .layout { display:flex; gap:20px; align-items:flex-start; width:100%; max-width:1400px; }
    .controls { width:320px; min-width:260px; }
    .canvasPanel { flex:1; display:flex; justify-content:center; }
    .debugPanel { width:160px; min-width:160px; display:none; }
    .debugPanel.visible { display:block; }
    .debugPanel button { width:100%; margin-top:8px; }
    .row { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; justify-content:flex-start; }
    label { display: inline-flex; gap: 8px; align-items: center; }
    input[type="number"] { width: 90px; padding: 6px 8px; }
    input[type="range"] { width: 220px; }
    select { padding: 6px 8px; }
    button { padding: 8px 12px; cursor: pointer; }
    canvas { border: 1px solid #ddd; margin-top: 12px; display:block; }
    .hint { color: #666; font-size: 14px; margin-top: 8px; line-height: 1.35; }
    .panel { margin-top: 10px; padding: 10px; border: 1px solid #eee; border-radius: 10px; background: #fafafa; box-sizing: border-box; }
    .agentRow { display:flex; align-items:center; gap:10px; padding:6px 0; flex-wrap: wrap; }
    .agentRow input[type="range"] { flex: 1 1 160px; min-width: 120px; }
    .swatch { width: 14px; height: 14px; border-radius: 4px; border: 1px solid rgba(0,0,0,0.15); }
    .pill { padding: 3px 8px; border: 1px solid #ddd; border-radius: 999px; font-size: 13px; background:#fff; display:inline-block; min-width:64px; text-align:center; }
    .small { font-size: 13px; color:#444; }
    @media (max-width: 800px) {
      .layout { flex-direction:column; align-items:center; }
      .controls { width:90%; }
      .canvasPanel { width:100%; }
      .debugPanel { width:90%; }
      input[type="range"] { width: 100%; }
    }
  </style>
</head>


<!-- 
  ______________________ HTML ____________________
  Document structure and elements (divs, buttons, inputs, canvas, etc.)
   - class and id attributes for styling and JS access
  __________________________________________
-->

<body>
  <div class="layout">
    <div class="controls">
      <div class="row">
        <label>
          Size (N×N)
          <input id="size" type="number" min="2" max="250" value="30" />
        </label>

        <label>
          Maze generator
          <select id="generator">
            <option value="wilson">Wilson (UST)</option>
            <option value="dfs">Recursive DFS</option>
            <option value="comb">Comb</option>
          </select>
        </label>

        <label>
          Agents
          <input id="agentCount" type="number" min="1" max="30" value="10" />
        </label>

        <label>
          Exploration Algorithm
          <select id="algo">
            <option value="random_dfs">Random DFS</option>
            <option value="cte">CTE (FGKP)</option>
            <option value="opt">2OPT (not fully operational yet)</option>
          </select>
        </label>

        <button id="generate">Generate</button>
        <button id="restart">Restart</button>
        <label style="margin-top:8px;">
          <input type="checkbox" id="debugToggle" />
          Debug
        </label>
      </div>

      <div class="hint">
      Algorithms: <br/>
        <b>Random DFS</b> : DFS with random choice of next visited neighbour. No-communication algorithm (slower).<br/>
        <b>CTE</b> [FGKP06]'s distributed algorithm. Agents go to nearest unfinished subtree, breaking ties with lead loaded. Distributed communications. <br/>
        <b>BFDN</b> TODO<br/>
        <b>Potential algo [CM24]</b> TODO<br/>
        <b>OPT</b> TODO
        <br/><br/>
      Maze generation: <br/>
        <b>Wilson</b> : uniform spanning tree, typical depth is n^(1/2). <br/>
        <b>Recursive DFS</b> : longer paths, harder to parallelize well (CTE does not do so well). Typical depth is n^(5/8)
      </div>

      <div id="timerPanel" class="panel">
        <div class="small">Elapsed time & Progress</div>
        <div class="row" style="align-items:center; gap:10px; justify-content:space-between;">
          <span id="timerVal" class="pill">0.00 s</span>
          <span id="movesVal" class="pill">0 moves</span>
          <span id="progressVal" class="pill">0 %</span>
        </div>
      </div>

      <div id="globalSpeedPanel" class="panel">
        <div class="small">All speeds</div>
        <div class="row" style="align-items:center; gap:10px;">
          <input id="allSpeed" type="range" min="0" max="99" step="1" value="20" />
          <span id="allSpeedVal" class="pill">20 / s</span>
        </div>
      </div>

      <div id="agentsPanel" class="panel"></div>
    </div>

    <div class="canvasPanel">
      <canvas id="canvas"></canvas>
    </div>

    <div class="debugPanel" id="debugPanel">
      <div class="panel">
        <div class="small" style="margin-bottom:8px;">Debug</div>
        <label>
          <input type="checkbox" id="chkShowLongestPath" />
          Longest Path
        </label>
        <label style="display:block; margin-top:8px;">
          <input type="checkbox" id="chkShadeDoneSubtrees" />
          Shade done subtrees (CTE)
        </label>
      </div>
    </div>
  </div>
  

  <!-- 
  ______________________ JAVASCRIPT ____________________
 -->


  <script type="module">
    // =========================
    // Labyrinthe "grille + murs"
    // Representation:
    // - each cell stores a bitmask of walls (N,E,S,W). A cleared bit means there's no wall.
    // - cells are indexed 0..(w*h-1). Index -> (x,y) via `i % width` and `i/width|0`.
    // - the class `GridMaze` provides carving and neighbour listing used by
    //   generators and agents.
    //
    // GridMaze details:
    // - `walls`: Uint8Array(length = width*height) storing bitmask N|E|S|W per cell
    // - `idx(x,y)`: convert (x,y) to linear index
    // - `xy(i)`: convert linear index to [x,y]
    // - `carve(i,j,dirIndex)`: remove wall between i and j using DIRS[dirIndex]
    // - `openNeighbors(i)`: list neighbour indices reachable from i (no wall)
    // =========================
    const N = 1, E = 2, S = 4, W = 8;

    const DIRS = [
      { dx: 0, dy: -1, bit: N, opp: S }, // 0
      { dx: 1, dy: 0,  bit: E, opp: W }, // 1
      { dx: 0, dy: 1,  bit: S, opp: N }, // 2
      { dx: -1, dy: 0, bit: W, opp: E }, // 3
    ];

    class GridMaze {
      constructor(width, height) {
        this.width = width;
        this.height = height;
        this.walls = new Uint8Array(width * height).fill(N | E | S | W); // add walls everywhere by default
      }
      idx(x, y) { return y * this.width + x; }
      xy(i) { return [i % this.width, (i / this.width) | 0]; }
      carve(i, j, dirIndex) {//remove wall between i and j in direction DIRS[dirIndex]
        const d = DIRS[dirIndex];
        this.walls[i] &= ~d.bit; // remove wall in i
        this.walls[j] &= ~d.opp; // remove opposite wall in j
      }
      openNeighbors(i) {
        const w = this.width, h = this.height;
        const x = i % w;
        const y = (i / w) | 0;
        const m = this.walls[i];

        const out = [];
        if (!(m & N) && y > 0) out.push(i - w);
        if (!(m & E) && x < w - 1) out.push(i + 1);
        if (!(m & S) && y < h - 1) out.push(i + w);
        if (!(m & W) && x > 0) out.push(i - 1);
        return out;
      }
    
      // -------------------------
      // Maze generators as GridMaze static methods
      // These were previously top-level functions. Keeping them as
      // static methods groups generation logic with the grid representation.
      // -------------------------
      static generateWilson(w, h) {
        const maze = new GridMaze(w, h);
        const n = w * h;
        const neigh = buildNeighborTable(w, h);

        const inTree = new Uint8Array(n);
        const next = new Int32Array(n).fill(-1);
        const nextDir = new Int8Array(n).fill(-1);
        const walkIndex = new Int32Array(n).fill(-1);

        const root = randInt(n);
        inTree[root] = 1;

        const walk = [];

        for (let start = 0; start < n; start++) {
          if (inTree[start]) continue;

          walk.length = 0;
          let cur = start;

          while (!inTree[cur]) {
            const seenAt = walkIndex[cur];
            if (seenAt !== -1) {
              for (let t = seenAt; t < walk.length; t++) {
                const v = walk[t];
                walkIndex[v] = -1;
                next[v] = -1;
                nextDir[v] = -1;
              }
              walk.length = seenAt;
            }

            walkIndex[cur] = walk.length;
            walk.push(cur);

            const options = neigh[cur];
            const [j, di] = options[randInt(options.length)];
            next[cur] = j;
            nextDir[cur] = di;
            cur = j;
          }

          for (let k = 0; k < walk.length; k++) {
            const v = walk[k];
            const j = next[v];
            const di = nextDir[v];
            maze.carve(v, j, di);
            inTree[v] = 1;
            walkIndex[v] = -1;
            next[v] = -1;
            nextDir[v] = -1;
          }
        }

        return maze;
      }

      static generateDfs(w, h) {
        const maze = new GridMaze(w, h);
        const n = w * h;
        const neigh = buildNeighborTable(w, h);

        const visited = new Uint8Array(n);
        const stack = [];

        const start = randInt(n);
        visited[start] = 1;
        stack.push(start);

        while (stack.length) {
          const v = stack[stack.length - 1];
          const options = neigh[v].filter(x => !visited[x[0]]);
          if (options.length === 0) {
            stack.pop();
            continue;
          }
          const [u, di] = options[randInt(options.length)];
          maze.carve(v, u, di);
          visited[u] = 1;
          stack.push(u);
        }

        return maze;
      }
      
      static generateComb(w, h) {
        // Deterministic comb:
        // Backbone: full top row (0,0) -> (w-1,0)
        // Teeth: each column has a vertical path down from the top row
        const maze = new GridMaze(w, h);

        // Helper: linear index
        const idx = (x, y) => y * w + x;

        // 1) Backbone: connect top row horizontally
        // Direction index here should match your carve() convention.
        // Common convention: 1 = east (right). Adjust if needed.
        const EAST = 1;

        for (let x = 0; x < w - 1; x++) {
          const a = idx(x, 0);
          const b = idx(x + 1, 0);
          maze.carve(a, b, EAST);
        }

        // 2) Teeth: connect each column vertically downward
        // Common convention: 2 = south (down). Adjust if needed.
        const SOUTH = 2;

        for (let x = 0; x < w; x++) {
          for (let y = 0; y < h - 1; y++) {
            const a = idx(x, y);
            const b = idx(x, y + 1);
            maze.carve(a, b, SOUTH);
          }
        }

        return maze;
      }

    }

    function randInt(n) { return (Math.random() * n) | 0; }

    function buildNeighborTable(w, h) {
      const n = w * h;
      const neigh = new Array(n);
      for (let i = 0; i < n; i++) {
        const x = i % w;
        const y = (i / w) | 0;
        const list = [];
        for (let di = 0; di < 4; di++) {
          const d = DIRS[di];
          const nx = x + d.dx, ny = y + d.dy;
          if (nx >= 0 && ny >= 0 && nx < w && ny < h) {
            list.push([ny * w + nx, di]);
          }
        }
        neigh[i] = list;
      }
      return neigh;
    }

    

    // =========================
    // Couleurs
    // =========================
    const PALETTE = [
      "#e6194b", "#3cb44b", "#4363d8", "#f58231",
      "#911eb4", "#46f0f0", "#f032e6", "#bcf60c",
      "#fabebe", "#008080", "#e6beff", "#9a6324",
    ];

    function hexToRgb(hex) {
      const h = hex.replace("#", "");
      const n = parseInt(h, 16);
      return { r: (n >> 16) & 255, g: (n >> 8) & 255, b: n & 255 };
    }

    // =========================
    // Exploration partagée : claims / visited
    // =========================
    let claimedBy = null;    // Int16Array: agentId du 1er visiteur, -1 sinon
    let claimedCount = 0;

    function resetClaims(nCells) {
      claimedBy = new Int16Array(nCells);
      claimedBy.fill(-1);
      claimedCount = 0;
    }

    function claimCell(agentId, cellIndex) {
      if (claimedBy[cellIndex] !== -1) return false;
      claimedBy[cellIndex] = agentId;
      claimedCount++;
      return true;
    }

    // =========================
    // Random DFS Agent
    // =========================
    class RandomDfsAgent {
      constructor(id, colorHex, maze, startIndex, speed = 120) {
        this.id = id;
        this.colorHex = colorHex;
        this.colorRgb = hexToRgb(colorHex);
        this.maze = maze;

        this.speed = speed;
        this.budget = 0;

        this.visited = new Uint8Array(maze.width * maze.height);
        this.stack = [startIndex];
        this.current = startIndex;
        this.done = false;

        this.visited[startIndex] = 1;
      }

      stepOnce() {
        if (this.done) return;

        if (this.stack.length === 0) {
          this.done = true;
          return;
        }

        const cur = this.stack[this.stack.length - 1];
        this.current = cur;

        const neighbors = this.maze.openNeighbors(cur);
        const candidates = [];
        for (let k = 0; k < neighbors.length; k++) {
          const j = neighbors[k];
          if (!this.visited[j]) candidates.push(j);
        }

        if (candidates.length > 0) {
          const j = candidates[randInt(candidates.length)];
          this.visited[j] = 1;
          this.stack.push(j);
          this.current = j;
          movesCount++;
          claimCell(this.id, j);
          return;
        }

        this.stack.pop();
        if (this.stack.length === 0) this.done = true;
        else {
          this.current = this.stack[this.stack.length - 1];
          movesCount++;
        }
      }
    }

    // =========================
    // CTE : arbre enraciné + compteurs
    // =========================
    // On construit un arbre enraciné à root (0,0). Comme le labyrinthe est un arbre, on obtient parent/children.
    function buildRootedTree(maze, root) {
      const n = maze.width * maze.height;
      const parent = new Int32Array(n).fill(-1);
      const order = [];                 // ordre BFS/DFS (pour éventuellement faire des passes)
      const children = Array.from({ length: n }, () => []);

      const q = [root];
      parent[root] = root;
      while (q.length) {
        const v = q.pop();
        order.push(v);
        const neigh = maze.openNeighbors(v);
        for (const u of neigh) {
          if (parent[u] !== -1) continue;
          parent[u] = v;
          children[v].push(u);
          q.push(u);
        }
      }
      parent[root] = -1;
      return { parent, children, order };
    }

    // Etat partagé CTE
    class CteShared {
      constructor(nCells) {
        this.n = nCells;
        this.subtreeAgents = new Int32Array(nCells); // #agents dans le sous-arbre du node
        this.subtreeDone = new Uint8Array(nCells);   // 0/1
        this.visited = new Uint8Array(nCells);       // 0/1 (exploration globale)
        this.visitedCount = 0;
      }

      // Met à jour subtreeAgents le long des ancêtres d'un node (inclu) : delta = +1 ou -1
      addAgentAlongAncestors(node, parent, delta) {
        let v = node;
        while (v !== -1) {
          this.subtreeAgents[v] += delta;
          v = parent[v];
        }
      }

      markVisited(node) {
        if (this.visited[node]) return false;
        this.visited[node] = 1;
        this.visitedCount++;
        return true;
      }

      // recalcul local "done" : un node est done si
      // - il est visité
      // - et tous ses enfants sont done
      tryUpdateDone(node, parent, children) {
        // remonte tant qu'on peut (amortized OK)
        let v = node;
        while (v !== -1) {
          if (!this.visited[v]) return;
          const ch = children[v];
          for (let i = 0; i < ch.length; i++) {
            if (!this.subtreeDone[ch[i]]) return;
          }
          if (this.subtreeDone[v]) return; // déjà done, stop
          this.subtreeDone[v] = 1;
          v = parent[v];
        }
      }

      allDone() {
        return this.visitedCount >= this.n;
      }
    }

    // =========================
    // OPT: Deterministic DFS path builder (includes backtracking)
    // =========================
    function buildDfsPath(maze, root) {
      const n = maze.width * maze.height;
      const visited = new Uint8Array(n);
      const path = [];

      function dfs(v) {
        visited[v] = 1;
        path.push(v);
        const neighbors = maze.openNeighbors(v);
        // Sort neighbors by index for deterministic order
        neighbors.sort((a, b) => a - b);
        for (const u of neighbors) {
          if (!visited[u]) {
            dfs(u);
            // Backtrack: return to v after exploring subtree rooted at u
            path.push(v);
          }
        }
      }

      dfs(root);
      return path;
    }

    // OPT Agent: navigate to chunk start, then DFS explore the chunk
    class OptAgent {
      constructor(id, colorHex, maze, root, path, chunkStartIdx, chunkEndIdx, speed = 120) {
        this.id = id;
        this.colorHex = colorHex;
        this.colorRgb = hexToRgb(colorHex);
        this.maze = maze;

        this.speed = speed;
        this.budget = 0;

        this.current = root;
        this.done = false;

        // Chunk nodes: set of nodes in the agent's assigned chunk
        this.chunkNodes = new Set(path.slice(chunkStartIdx, chunkEndIdx));
        this.chunkStartNode = path[chunkStartIdx];

        // Phase 1: navigate to chunk start using shortest path (BFS)
        this.phase = "navigate";
        this.shortestPath = this._computeShortestPath(root, this.chunkStartNode);
        this.pathIndex = 0;

        claimCell(this.id, root);
      }

      _computeShortestPath(from, to) {
        const n = this.maze.width * this.maze.height;
        const parent = new Int32Array(n).fill(-1);
        const q = [from];
        parent[from] = from;

        while (q.length) {
          const v = q.shift();
          if (v === to) break;
          const neighbors = this.maze.openNeighbors(v);
          for (const u of neighbors) {
            if (parent[u] === -1) {
              parent[u] = v;
              q.push(u);
            }
          }
        }

        // Reconstruct path from 'from' to 'to'
        const path = [];
        let v = to;
        while (v !== from) {
          path.unshift(v);
          v = parent[v];
        }
        path.unshift(from);
        return path;
      }

      stepOnce() {
        if (this.done) return;

        if (this.phase === "navigate") {
          // Move along shortest path to chunk start
          if (this.pathIndex < this.shortestPath.length - 1) {
            this.pathIndex++;
            this.current = this.shortestPath[this.pathIndex];
            movesCount++;
            claimCell(this.id, this.current);
          } else {
            // Reached chunk start, switch to DFS exploration
            this.phase = "explore";
            this.visited = new Uint8Array(this.maze.width * this.maze.height);
            this.stack = [this.chunkStartNode];
            this.visited[this.chunkStartNode] = 1;
            this.current = this.chunkStartNode;
          }
        } else if (this.phase === "explore") {
          // DFS exploration within chunk
          if (this.stack.length === 0) {
            this.done = true;
            return;
          }

          const cur = this.stack[this.stack.length - 1];
          this.current = cur;

          const neighbors = this.maze.openNeighbors(cur);
          const candidates = [];
          for (const j of neighbors) {
            if (!this.visited[j] && this.chunkNodes.has(j)) {
              candidates.push(j);
            }
          }

          if (candidates.length > 0) {
            const j = candidates[randInt(candidates.length)];
            this.visited[j] = 1;
            this.stack.push(j);
            this.current = j;
            movesCount++;
            claimCell(this.id, j);
          } else {
            this.stack.pop();
            if (this.stack.length > 0) {
              movesCount++;
            }
          }
        }
      }
    }

    class CteAgent {
      constructor(id, colorHex, maze, root, parent, children, shared, speed = 120) {
        this.id = id;
        this.colorHex = colorHex;
        this.colorRgb = hexToRgb(colorHex);
        this.maze = maze;

        this.root = root;
        this.parent = parent;
        this.children = children;
        this.shared = shared;

        this.speed = speed;
        this.budget = 0;

        this.current = root;
        this.done = false;

        // cet agent compte dans les sous-arbres des ancêtres du root (juste root ici)
        shared.addAgentAlongAncestors(root, parent, +1);

        // visite root globalement + claim (si personne ne l’a fait)
        if (shared.markVisited(root)) {
          claimCell(this.id, root);
          shared.tryUpdateDone(root, parent, children);
        }
      }

      // Choix à l'intersection :
      // - si tous les enfants sont done => remonter
      // - sinon choisir un enfant non-done avec subtreeAgents minimal (tie-break aléatoire)
      stepOnce() {
        if (this.done) return;
        if (this.shared.allDone()) { this.done = true; return; }

        const v = this.current;
        const ch = this.children[v];

        // Si aucun enfant : feuille => remonte
        // Si tous les enfants done => remonte
        let best = -1;
        let bestLoad = Infinity;
        let ties = [];

        for (let i = 0; i < ch.length; i++) {
          const u = ch[i];
          if (this.shared.subtreeDone[u]) continue;
          const load = this.shared.subtreeAgents[u];
          if (load < bestLoad) {
            bestLoad = load;
            ties = [u];
          } else if (load === bestLoad) {
            ties.push(u);
          }
        }

        let next;
        if (ties.length > 0) {
          next = ties[randInt(ties.length)];
        } else {
          // remonter
          next = this.parent[v];
          if (next === -1) {
            // on est à la racine : si rien à faire, stop
            this.done = true;
            return;
          }
        }

        // déplacement : mise à jour subtreeAgents le long des ancêtres
        this.shared.addAgentAlongAncestors(this.current, this.parent, -1);
        this.current = next;
        movesCount++;
        this.shared.addAgentAlongAncestors(this.current, this.parent, +1);

        // si on arrive sur un nœud non encore visité globalement => le marquer + claim couleur
        if (this.shared.markVisited(this.current)) {
          claimCell(this.id, this.current);
        }

        // mise à jour des flags done (peut remonter)
        this.shared.tryUpdateDone(this.current, this.parent, this.children);

        if (this.shared.allDone()) this.done = true;
      }
    }

    // =========================
    // Rendu
    // =========================
    // Canvas sizing (default target size)
    function fitCanvas(canvas, targetCssPx = 900) {
      const dpr = window.devicePixelRatio || 1;
      const parentW = (canvas.parentElement && canvas.parentElement.clientWidth) || document.body.clientWidth;
      const cssW = Math.min(targetCssPx, Math.max(100, Math.floor(parentW - 32)));
      const cssH = cssW;

      canvas.style.width = cssW + "px";
      canvas.style.height = cssH + "px";
      canvas.width = Math.floor(cssW * dpr);
      canvas.height = Math.floor(cssH * dpr);

      const ctx = canvas.getContext("2d");
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      return { ctx, cssW, cssH };
    }

    function draw(canvas, maze, claimedBy, agents) {
      const { ctx, cssW, cssH } = fitCanvas(canvas);

      const w = maze.width, h = maze.height;
      const pad = 10;
      const cell = Math.min((cssW - 2 * pad) / w, (cssH - 2 * pad) / h);

      ctx.clearRect(0, 0, cssW, cssH);
      ctx.fillStyle = "#fff";
      ctx.fillRect(0, 0, cssW, cssH);

      const ox = pad, oy = pad;

      // optional: shade nodes whose subtree is fully done (CTE)
      try {
        const shade = document.getElementById('chkShadeDoneSubtrees')?.checked;
        if (shade && cteShared) {
          ctx.fillStyle = 'rgba(0,0,0,0.22)';
          for (let i = 0; i < cteShared.n; i++) {
            if (cteShared.subtreeDone[i]) {
              const x = i % w;
              const y = (i / w) | 0;
              ctx.fillRect(ox + x * cell, oy + y * cell, cell, cell);
            }
          }
        }
      } catch (e) {
        // defensive: if checkbox not present or cteShared missing, ignore
      }

      // claims
      for (let i = 0; i < claimedBy.length; i++) {
        const aId = claimedBy[i];
        if (aId < 0) continue;
        const a = agents[aId];
        if (!a) continue;

        const x = i % w;
        const y = (i / w) | 0;
        ctx.fillStyle = `rgba(${a.colorRgb.r}, ${a.colorRgb.g}, ${a.colorRgb.b}, 0.18)`;
        ctx.fillRect(ox + x * cell, oy + y * cell, cell, cell);
      }

      // murs
      ctx.lineWidth = Math.max(1, cell * 0.08);
      ctx.lineCap = "square";
      ctx.strokeStyle = "#111";

      const px = ox + 0.5;
      const py = oy + 0.5;

      ctx.beginPath();
      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
          const i = y * w + x;
          const m = maze.walls[i];
          const x0 = px + x * cell;
          const y0 = py + y * cell;
          const x1 = x0 + cell;
          const y1 = y0 + cell;

          if (m & N) { ctx.moveTo(x0, y0); ctx.lineTo(x1, y0); }
          if (m & W) { ctx.moveTo(x0, y0); ctx.lineTo(x0, y1); }
          if (x === w - 1 && (m & E)) { ctx.moveTo(x1, y0); ctx.lineTo(x1, y1); }
          if (y === h - 1 && (m & S)) { ctx.moveTo(x0, y1); ctx.lineTo(x1, y1); }
        }
      }
      ctx.stroke();

      // debug path (longest path)
      if (debugPath && debugPath.length > 0) {
        ctx.strokeStyle = "#ff0000";
        ctx.lineWidth = Math.max(2, cell * 0.15);
        ctx.lineCap = "round";
        ctx.lineJoin = "round";
        ctx.beginPath();
        for (let k = 0; k < debugPath.length; k++) {
          const i = debugPath[k];
          const x = i % w;
          const y = (i / w) | 0;
          const cx = ox + x * cell + cell * 0.5;
          const cy = oy + y * cell + cell * 0.5;
          if (k === 0) ctx.moveTo(cx, cy);
          else ctx.lineTo(cx, cy);
        }
        ctx.stroke();
      }

      // agents
      for (const a of agents) {
        const i = a.current;
        const x = i % w;
        const y = (i / w) | 0;

        const cx = ox + x * cell + cell * 0.5;
        const cy = oy + y * cell + cell * 0.5;
        const r = Math.max(3, cell * 0.18);

        ctx.fillStyle = `rgba(${a.colorRgb.r}, ${a.colorRgb.g}, ${a.colorRgb.b}, 0.25)`;
        ctx.beginPath();
        ctx.arc(cx, cy, r * 1.6, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = a.colorHex;
        ctx.beginPath();
        ctx.arc(cx, cy, r, 0, Math.PI * 2);
        ctx.fill();

        ctx.strokeStyle = "rgba(255,255,255,0.9)";
        ctx.lineWidth = Math.max(1, cell * 0.06);
        ctx.beginPath();
        ctx.arc(cx, cy, r, 0, Math.PI * 2);
        ctx.stroke();
      }

      // marqueur départ (haut gauche)
      ctx.fillStyle = "rgba(0,0,0,0.6)";
      const sx = 0, sy = 0;
      ctx.beginPath();
      ctx.arc(ox + sx * cell + cell * 0.25, oy + sy * cell + cell * 0.25, Math.max(2, cell * 0.12), 0, Math.PI * 2);
      ctx.fill();
    }

    // =========================
    // UI agents
    // =========================
    const sizeInput = document.getElementById("size");
    const algoSelect = document.getElementById("algo");
    const allSpeedInput = document.getElementById("allSpeed");
    const allSpeedVal = document.getElementById("allSpeedVal");
    const btnGenerate = document.getElementById("generate");
    const btnRestart = document.getElementById("restart");
    const agentCountInput = document.getElementById("agentCount");
    const agentsPanel = document.getElementById("agentsPanel");
    const canvas = document.getElementById("canvas");

    let maze = null;
    let agents = [];
    let lastT = performance.now();
    // throttle UI text updates (ms)
    let lastUiUpdate = 0;
    let debugPath = null; // path to render in red for debugging
    let movesCount = 0; // shared counter for agent moves

    // Timer state (ms)
    const timerValEl = document.getElementById("timerVal");
    let timerRunning = false;
    let timerElapsed = 0; // milliseconds

    // CTE-only shared + rooted tree
    let cteTree = null;     // { parent, children, order }
    let cteShared = null;   // CteShared

    // Expose for debugging in console
    const debugVars = { get maze() { return maze; }, get agents() { return agents; }, get cteTree() { return cteTree; }, get cteShared() { return cteShared; } };
    window._debug = debugVars;

    // Find the deepest node and return the longest path from root to that node
    function findLongestPath(mazeObj, root) {
      const n = mazeObj.width * mazeObj.height;
      const depth = new Int32Array(n).fill(-1);
      const parent = new Int32Array(n).fill(-1);
      const q = [root];
      depth[root] = 0;
      parent[root] = -1;

      let deepestNode = root;
      let maxDepth = 0;

      while (q.length) {
        const v = q.shift();
        if (depth[v] > maxDepth) {
          maxDepth = depth[v];
          deepestNode = v;
        }
        const neighbors = mazeObj.openNeighbors(v);
        for (const u of neighbors) {
          if (depth[u] === -1) {
            depth[u] = depth[v] + 1;
            parent[u] = v;
            q.push(u);
          }
        }
      }

      // Reconstruct path from root to deepestNode
      const path = [];
      let v = deepestNode;
      while (v !== -1) {
        path.unshift(v);
        v = parent[v];
      }
      return path;
    }

    function buildAgentsUI() {
      agentsPanel.innerHTML = "";

      const header = document.createElement("div");
      header.className = "small";
      header.textContent = "Agent speeds :";
      agentsPanel.appendChild(header);

      agents.forEach((a) => {
        const row = document.createElement("div");
        row.className = "agentRow";

        const sw = document.createElement("div");
        sw.className = "swatch";
        sw.style.background = a.colorHex;

        const name = document.createElement("span");
        name.textContent = `Agent ${a.id + 1}`;
        name.style.fontWeight = "600";

        const slider = document.createElement("input");
        slider.type = "range";
        slider.min = "0";
        slider.max = "99";
        slider.step = "1";
        slider.value = String(a.speed);

        const valPill = document.createElement("span");
        valPill.className = "pill";
        valPill.textContent = `${a.speed} / s`;

        slider.addEventListener("input", () => {
          a.speed = Number(slider.value) || 0;
          valPill.textContent = `${a.speed} / s`;
          // keep global slider value in sync if all agents share the same speed
          if (allSpeedInput) {
            const rows = agentsPanel.querySelectorAll('.agentRow');
            let same = true;
            for (let i = 0; i < rows.length; i++) {
              const s = rows[i].querySelector('input[type="range"]');
              if (!s) continue;
              if (Number(s.value) !== a.speed) { same = false; break; }
            }
            if (same) {
              allSpeedInput.value = String(a.speed);
              if (allSpeedVal) allSpeedVal.textContent = `${a.speed} / s`;
            }
          }
        });

        const status = document.createElement("span");
        status.className = "small";
        status.textContent = a.done ? "✓ terminé" : "… explore";
        row._statusEl = status;

        row.appendChild(sw);
        row.appendChild(name);
        row.appendChild(slider);
        row.appendChild(valPill);
        row.appendChild(status);
        agentsPanel.appendChild(row);
      });
    }

    // global all-speed slider: set every agent speed and update UI
    if (allSpeedInput) {
      allSpeedInput.addEventListener('input', () => {
        const v = Number(allSpeedInput.value) || 0;
        if (allSpeedVal) allSpeedVal.textContent = `${v} / s`;
        agents.forEach(a => { a.speed = v; });
        const rows = agentsPanel.querySelectorAll('.agentRow');
        rows.forEach(row => {
          const s = row.querySelector('input[type="range"]');
          const pill = row.querySelector('.pill');
          if (s) s.value = String(v);
          if (pill) pill.textContent = `${v} / s`;
        });
      });
    }

    function updateAgentsStatusUI() {
      const rows = agentsPanel.querySelectorAll(".agentRow");
      rows.forEach((row, i) => {
        const statusEl = row._statusEl;
        if (!statusEl) return;
        statusEl.textContent = agents[i].done ? "✓ terminé" : "… explore";
      });
    }

    // =========================
    // Construction des agents selon algo
    // =========================
    function createAgents(count, algo) {
      const nCells = maze.width * maze.height;
      // read speeds from existing sliders in the UI so speeds persist across restarts/algo changes
      // fallback to the current `agents` array speeds if sliders are not present
      let prevSpeeds = agents.map(a => a.speed);
      const sliders = agentsPanel.querySelectorAll('input[type="range"]');
      if (sliders && sliders.length > 0) prevSpeeds = Array.from(sliders).map(s => {
        const v = Number(s.value);
        return Number.isFinite(v) ? v : 20;
      });
      resetClaims(nCells);

      const start = maze.idx(0, 0); // haut gauche pour tous
      agents = [];

      if (algo === "cte") {
        // construire arbre enraciné + shared
        cteTree = buildRootedTree(maze, start);
        cteShared = new CteShared(nCells);

        for (let i = 0; i < count; i++) {
          const color = PALETTE[i % PALETTE.length];
          const speed = prevSpeeds[i] ?? 20;
          const a = new CteAgent(i, color, maze, start, cteTree.parent, cteTree.children, cteShared, speed);
          agents.push(a);
        }
      } else if (algo === "opt") {
        // OPT: deterministic DFS path divided into chunks
        cteTree = null;
        cteShared = null;

        const path = buildDfsPath(maze, start);
        const pathLen = path.length;
        const chunkSize = Math.ceil(pathLen / count);

        for (let i = 0; i < count; i++) {
          const color = PALETTE[i % PALETTE.length];
          const speed = prevSpeeds[i] ?? 20;
          const chunkStart = i * chunkSize;
          const chunkEnd = Math.min((i + 1) * chunkSize, pathLen);
          const a = new OptAgent(i, color, maze, start, path, chunkStart, chunkEnd, speed);
          agents.push(a);
        }
      } else {
        // random dfs (local)
        cteTree = null;
        cteShared = null;

        for (let i = 0; i < count; i++) {
          const color = PALETTE[i % PALETTE.length];
          const speed = prevSpeeds[i] ?? 20;
          const a = new RandomDfsAgent(i, color, maze, start, speed);
          // claim start
          claimCell(a.id, start);
          agents.push(a);
        }
      }

      buildAgentsUI();
      draw(canvas, maze, claimedBy, agents);

      lastT = performance.now();
      agents.forEach(a => a.budget = 0);
      movesCount = 0;  // reset moves counter

      // restart timer when agents are (re)created
      timerElapsed = 0;
      timerRunning = agents.length > 0;
      if (timerValEl) timerValEl.textContent = `${(timerElapsed / 1000).toFixed(2)} s`;
    }

    function restartExploration() {
      if (!maze) return;
      const count = agents.length || Math.max(1, Math.min(30, Number(agentCountInput.value) || 1));
      createAgents(count, algoSelect.value);
    }

    function generateNewMaze() {
      let n = Number(sizeInput.value);
      if (!Number.isFinite(n)) n = 30;
      n = Math.max(2, Math.min(500, Math.floor(n)));

      const gen = document.getElementById('generator')?.value || 'wilson';
      if (gen === 'dfs') maze = GridMaze.generateDfs(n, n);
      else if (gen === 'comb') maze = GridMaze.generateComb(n, n);
      else maze = GridMaze.generateWilson(n, n);

      const count = Math.max(1, Math.min(30, Number(agentCountInput.value) || 1));
      createAgents(count, algoSelect.value);
    }

    btnGenerate.addEventListener("click", generateNewMaze);
    btnRestart.addEventListener("click", restartExploration);

    algoSelect.addEventListener("change", () => {
      // garder labyrinthe, mais changer algo => restart
      if (!maze) return;
      restartExploration();
    });

    document.getElementById("debugToggle").addEventListener("change", () => {
      const debugPanel = document.getElementById("debugPanel");
      if (debugPanel.classList.contains("visible")) {
        debugPanel.classList.remove("visible");
      } else {
        debugPanel.classList.add("visible");
      }
    });

    document.getElementById("chkShowLongestPath").addEventListener("change", (e) => {
      if (!maze) return;
      if (e.target.checked) {
        const root = maze.idx(0, 0);
        debugPath = findLongestPath(maze, root);
      } else {
        debugPath = null;
      }
      draw(canvas, maze, claimedBy, agents);
    });

    window.addEventListener("resize", () => {
      if (maze) draw(canvas, maze, claimedBy, agents);
    });

    // =========================
    // Loop simulation
    // =========================
    function allDone() {
      if (algoSelect.value === "cte") return cteShared?.allDone() ?? false;
      // sinon: considéré terminé quand toutes les cellules sont claim (global)
      return claimedCount >= claimedBy.length;
    }

    function tick(t) {
      const dt = Math.max(0, (t - lastT) / 1000);
      lastT = t;

      // update timer (dt is in seconds)
      if (timerRunning) {
        timerElapsed += dt * 1000;
      }

      // Throttle DOM updates for timer/moves/progress to reduce visual jitter
      if (t - lastUiUpdate >= 100) {
        lastUiUpdate = t;
        if (timerValEl) timerValEl.textContent = `${(timerElapsed / 1000).toFixed(2)} s`;

        // update exploration progress
        const progressEl = document.getElementById("progressVal");
        if (maze && progressEl) {
          const totalCells = maze.width * maze.height;
          const explorationPercent = Math.round((claimedCount / totalCells) * 100);
          progressEl.textContent = `${explorationPercent} %`;
        }

        // update moves counter
        const movesEl = document.getElementById("movesVal");
        if (movesEl) movesEl.textContent = `${movesCount} moves`;
      }

      if (maze && agents.length > 0 && !allDone()) {
        const maxStepsPerFramePerAgent = 2500;

        for (const a of agents) {
          if (a.done) continue;

          a.budget += dt * a.speed;
          const stepsToDo = Math.min(maxStepsPerFramePerAgent, Math.floor(a.budget));

          for (let k = 0; k < stepsToDo && !a.done; k++) {
            a.stepOnce();
          }

          a.budget -= stepsToDo;
        }
      }

      // if exploration completed, freeze timer
      if (maze && agents.length > 0 && allDone()) {
        timerRunning = false;
      }

      if (maze) {
        draw(canvas, maze, claimedBy, agents);
        updateAgentsStatusUI();
      }

      requestAnimationFrame(tick);
    }

    // init
    generateNewMaze();
    requestAnimationFrame(tick);
  </script>
</body>
</html>
