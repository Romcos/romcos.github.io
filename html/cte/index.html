<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Multi Agent Maze Exploration / Collective Tree Exploration</title>
  <!-- Copyright (c) 2026 Romain — see LICENSE for terms. -->

<!-- 
  ______________________ CSS ____________________
  Complete CSS Stylying 
    body, button, select: refer to html elements
    .layout, .controls etc.: are class selectors
  __________________________________________
-->
  <style>
    body { display:flex; flex-direction:column; align-items:center; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 16px; }
    .layout { display:flex; gap:20px; align-items:flex-start; width:100%; max-width:1400px; }
    .controls { width:320px; min-width:260px; }
    .canvasPanel { flex:1; display:flex; justify-content:center; }
    .debugPanel { width:160px; min-width:160px; display:none; }
    .debugPanel.visible { display:block; }
    .debugPanel button { width:100%; margin-top:8px; }
    .row { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; justify-content:flex-start; }
    label { display: inline-flex; gap: 8px; align-items: center; }
    input[type="number"] { width: 90px; padding: 6px 8px; }
    input[type="range"] { width: 220px; }
    select { padding: 6px 8px; }
    button { padding: 8px 12px; cursor: pointer; }
    canvas { border: 1px solid #ddd; margin-top: 12px; display:block; }
    .hint { color: #666; font-size: 14px; margin-top: 8px; line-height: 1.35; }
    .panel { margin-top: 10px; padding: 10px; border: 1px solid #eee; border-radius: 10px; background: #fafafa; box-sizing: border-box; }
    .agentRow { display:flex; align-items:center; gap:10px; padding:6px 0; flex-wrap: wrap; }
    .agentRow input[type="range"] { flex: 1 1 160px; min-width: 120px; }
    .swatch { width: 14px; height: 14px; border-radius: 4px; border: 1px solid rgba(0,0,0,0.15); }
    .pill { padding: 3px 8px; border: 1px solid #ddd; border-radius: 999px; font-size: 13px; background:#fff; display:inline-block; min-width:64px; text-align:center; }
    .small { font-size: 13px; color:#444; }
    @media (max-width: 800px) {
      .layout { flex-direction:column; align-items:center; }
      .controls { width:90%; }
      .canvasPanel { width:100%; }
      .debugPanel { width:90%; }
      input[type="range"] { width: 100%; }
    }
  </style>
</head>


<!-- 
  ______________________ HTML ____________________
  Document structure and elements (divs, buttons, inputs, canvas, etc.)
   - class and id attributes for styling and JS access
  __________________________________________
-->

<body>
  <div class="layout">
    <div class="controls">
      <div class="row">
        <label>
          Size (N×N)
          <input id="size" type="number" min="2" max="250" value="30" />
        </label>

        <label>
          Maze generator
          <select id="generator">
            <option value="wilson">Wilson (UST)</option>
            <option value="dfs">Recursive DFS</option>
            <option value="comb">Comb</option>
            <option value="binary_tree">Binary Tree</option>
            <!--
            <option value="kruskal">Kruskal</option>
            <option value="sidewinder">Sidewinder</option>
            <option value="eller">Eller</option>
            <option value="prim">Prim</option>
            <option value="hunt_and_kill">Hunt and Kill</option>
            <option value="spine_branches">Spine + Branches</option>
            -->
          </select>
        </label>

        <label>
          Agents (k)
          <input id="agentCount" type="number" min="1" max="30" value="3" />
        </label>

        <label>
          Exploration Algorithm
          <select id="algo">
            <option value="random_dfs">Random DFS</option>
            <option value="cte">CTE</option>
            <option value="lga3">LGA (v3)</option>
            <option value="opt">2OPT</option>
            <!--
            <option value="lga">LGA (Locally Greedy)</option>
            <option value="lga2">LGA2 (Locally Greedy v2)</option>
            <option value="lga4">LGA4 (Locally Greedy v4)</option>
            -->
          </select>
        </label>

        <button id="generate">Generate</button>
        <button id="restart">Restart</button>
        <label style="margin-top:8px;">
          <input type="checkbox" id="debugToggle" />
          Debug
        </label>
      </div>

      <div class="hint">
       - Maze generation: <br/>
      <b>Wilson</b> : uniform spanning tree, D ~ N. <br/>
      <b>Recursive DFS</b> : longer paths, D ~ N^(5/4).<br/>
      <b>Comb</b> : difficult for CTE.<br/>
      <b>Binary Tree</b> : biased carving (north/east), diagonal flows.
      <!--
      <b>Kruskal</b> : randomized Kruskal, bushier with many short branches.
      <b>Sidewinder</b> : long horizontal corridors with occasional vertical links.
      <b>Eller</b> : row-by-row merges with guaranteed vertical links per set.
      <b>Prim</b> : randomized Prim, bushy with many short branches.
      <b>Hunt and Kill</b> : long runs with periodic hunts for new starts.
      <b>Spine + Branches</b> : biased spine with a few long offshoots.
      -->
      <br/><br/>
       - Algorithms: <br/>
      <b>Random DFS</b> independent DFSs with random tie-breaking. No-communication.<br/>
      <b>CTE</b> Greedy algorithm. Agents go to nearest unfinished subtree. Accelerated version (using complete communications). <br/>
      <b>LGA</b> Locally greedy v3: reanchor with shared anchor counts.<br/>
      <b>OPT</b> 2-approximation of offline algorithm. Full knowledge.
      <!--
      <b>LGA</b> First naive locally greedy implementation: reanchor to shallowest frontier node.<br/>
      <b>LGA2</b> Locally greedy v2: reanchor by minimizing lambda * depth(v) + dist(u,v).<br/>
      <b>LGA3</b> Locally greedy v3: reanchor with shared anchor counts.<br/>
      <b>LGA4</b> Locally greedy v4: reanchor with shared anchor counts (log variant).<br/>
      
      <b>Potential algo [CM24]</b> TODO. Full communication.<br/>
      <b>OPT</b> 2-approximation of offline algorithm. Full knowledge.
      -->
      <br/><br/>
       - Suggested parameters: Try with large number of robots (up to 30), high speeds, and large N (up to 300) to see nice patterns emerge. 
      </div>

      <div id="timerPanel" class="panel">
        <div class="small">Elapsed time & Progress</div>
        <div class="row" style="align-items:center; gap:10px; justify-content:space-between;">
          <span id="timerVal" class="pill">0.00 s</span>
          <span id="movesVal" class="pill">0 moves</span>
          <span id="progressVal" class="pill">0 %</span>
        </div>
      </div>

      <div id="globalSpeedPanel" class="panel">
        <div class="small">All speeds</div>
        <div class="row" style="align-items:center; gap:10px;">
          <input id="allSpeed" type="range" min="0" max="99" step="1" value="20" />
          <span id="allSpeedVal" class="pill">20 / s</span>
        </div>
      </div>

      <div id="agentsPanel" class="panel"></div>
    </div>

    <div class="canvasPanel">
      <canvas id="canvas"></canvas>
    </div>

    <div class="debugPanel" id="debugPanel">
      <div class="panel">
        <div class="small" style="margin-bottom:8px;">Debug</div>
        <label>
          <input type="checkbox" id="chkShowLongestPath" />
          Longest Path
        </label>
        <label style="display:block; margin-top:8px;">
          <input type="checkbox" id="chkShadeDoneSubtrees" />
          Shade done subtrees (CTE)
        </label>
        <label style="display:block; margin-top:8px;">
          <input type="checkbox" id="chkShadeUnvisited" />
          Shade unvisited nodes
        </label>
        <label style="display:block; margin-top:8px;">
          <input type="checkbox" id="chkHighlightDepth" />
          Highlight depth
          <input id="depthLevel" type="number" min="0" step="1" value="0" style="margin-left:6px; width:80px;" />
        </label>
        <label style="display:block; margin-top:8px;">
          <input type="checkbox" id="chkShowLca" />
          Show LCA
          <input id="lcaU" type="number" min="0" step="1" value="0" style="margin-left:6px; width:80px;" />
          <input id="lcaV" type="number" min="0" step="1" value="0" style="margin-left:6px; width:80px;" />
        </label>
        <label style="display:block; margin-top:8px;">
          <input type="checkbox" id="chkShowFrontier" />
          Show frontier nodes
        </label>
        <label style="display:block; margin-top:8px;">
          <span>Lambda (LGA2)</span>
          <input id="lgaLambda" type="number" min="0" step="0.1" value="1" style="margin-left:6px; width:80px;" />
        </label>
        <label style="display:block; margin-top:8px;">
          <input type="checkbox" id="chkShowAnchorCounts" />
          Show x (anchor counts)
        </label>
      </div>
    </div>
  </div>
  

  <!-- 
  ______________________ JAVASCRIPT ____________________
 -->


  <script type="module">
    // =========================
    // Labyrinthe "grille + murs"
    // Representation:
    // - each cell stores a bitmask of walls (N,E,S,W). A cleared bit means there's no wall.
    // - cells are indexed 0..(w*h-1). Index -> (x,y) via `i % width` and `i/width|0`.
    // - the class `GridMaze` provides carving and neighbour listing used by
    //   generators and agents.
    //
    // GridMaze details:
    // - `walls`: Uint8Array(length = width*height) storing bitmask N|E|S|W per cell
    // - `idx(x,y)`: convert (x,y) to linear index
    // - `xy(i)`: convert linear index to [x,y]
    // - `carve(i,j,dirIndex)`: remove wall between i and j using DIRS[dirIndex]
    // - `openNeighbors(i)`: list neighbour indices reachable from i (no wall)
    // =========================
    const N = 1, E = 2, S = 4, W = 8;

    const DIRS = [
      { dx: 0, dy: -1, bit: N, opp: S }, // 0
      { dx: 1, dy: 0,  bit: E, opp: W }, // 1
      { dx: 0, dy: 1,  bit: S, opp: N }, // 2
      { dx: -1, dy: 0, bit: W, opp: E }, // 3
    ];

    class GridMaze {
      constructor(width, height) {
        this.width = width;
        this.height = height;
        this.walls = new Uint8Array(width * height).fill(N | E | S | W); // add walls everywhere by default
      }
      idx(x, y) { return y * this.width + x; }
      xy(i) { return [i % this.width, (i / this.width) | 0]; }
      carve(i, j, dirIndex) {//remove wall between i and j in direction DIRS[dirIndex]
        const d = DIRS[dirIndex];
        this.walls[i] &= ~d.bit; // remove wall in i
        this.walls[j] &= ~d.opp; // remove opposite wall in j
      }
      openNeighbors(i) {
        const w = this.width, h = this.height;
        const x = i % w;
        const y = (i / w) | 0;
        const m = this.walls[i];

        const out = [];
        if (!(m & N) && y > 0) out.push(i - w);
        if (!(m & E) && x < w - 1) out.push(i + 1);
        if (!(m & S) && y < h - 1) out.push(i + w);
        if (!(m & W) && x > 0) out.push(i - 1);
        return out;
      }
    
      // -------------------------
      // Maze generators as GridMaze static methods
      // These were previously top-level functions. Keeping them as
      // static methods groups generation logic with the grid representation.
      // -------------------------
      static generateWilson(w, h) {
        const maze = new GridMaze(w, h);
        const n = w * h;
        const neigh = buildNeighborTable(w, h);

        const inTree = new Uint8Array(n);
        const next = new Int32Array(n).fill(-1);
        const nextDir = new Int8Array(n).fill(-1);
        const walkIndex = new Int32Array(n).fill(-1);

        const root = randInt(n);
        inTree[root] = 1;

        const walk = [];

        for (let start = 0; start < n; start++) {
          if (inTree[start]) continue;

          walk.length = 0;
          let cur = start;

          while (!inTree[cur]) {
            const seenAt = walkIndex[cur];
            if (seenAt !== -1) {
              for (let t = seenAt; t < walk.length; t++) {
                const v = walk[t];
                walkIndex[v] = -1;
                next[v] = -1;
                nextDir[v] = -1;
              }
              walk.length = seenAt;
            }

            walkIndex[cur] = walk.length;
            walk.push(cur);

            const options = neigh[cur];
            const [j, di] = options[randInt(options.length)];
            next[cur] = j;
            nextDir[cur] = di;
            cur = j;
          }

          for (let k = 0; k < walk.length; k++) {
            const v = walk[k];
            const j = next[v];
            const di = nextDir[v];
            maze.carve(v, j, di);
            inTree[v] = 1;
            walkIndex[v] = -1;
            next[v] = -1;
            nextDir[v] = -1;
          }
        }

        return maze;
      }

      static generateDfs(w, h) {
        const maze = new GridMaze(w, h);
        const n = w * h;
        const neigh = buildNeighborTable(w, h);

        const visited = new Uint8Array(n);
        const stack = [];

        const start = randInt(n);
        visited[start] = 1;
        stack.push(start);

        while (stack.length) {
          const v = stack[stack.length - 1];
          const options = neigh[v].filter(x => !visited[x[0]]);
          if (options.length === 0) {
            stack.pop();
            continue;
          }
          const [u, di] = options[randInt(options.length)];
          maze.carve(v, u, di);
          visited[u] = 1;
          stack.push(u);
        }

        return maze;
      }
      
      static generateComb(w, h) {
        // Deterministic comb:
        // Backbone: full top row (0,0) -> (w-1,0)
        // Teeth: each column has a vertical path down from the top row
        const maze = new GridMaze(w, h);

        // Helper: linear index
        const idx = (x, y) => y * w + x;

        // 1) Backbone: connect top row horizontally
        // Direction index here should match your carve() convention.
        // Common convention: 1 = east (right). Adjust if needed.
        const EAST = 1;

        for (let x = 0; x < w - 1; x++) {
          const a = idx(x, 0);
          const b = idx(x + 1, 0);
          maze.carve(a, b, EAST);
        }

        // 2) Teeth: connect each column vertically downward
        // Common convention: 2 = south (down). Adjust if needed.
        const SOUTH = 2;

        for (let x = 0; x < w; x++) {
          for (let y = 0; y < h - 1; y++) {
            const a = idx(x, y);
            const b = idx(x, y + 1);
            maze.carve(a, b, SOUTH);
          }
        }

        return maze;
      }

      static generateKruskal(w, h) {
        const maze = new GridMaze(w, h);
        const n = w * h;

        const parent = new Int32Array(n);
        const rank = new Int8Array(n);
        for (let i = 0; i < n; i++) parent[i] = i;

        const find = (x) => {
          let r = x;
          while (parent[r] !== r) r = parent[r];
          while (parent[x] !== x) {
            const p = parent[x];
            parent[x] = r;
            x = p;
          }
          return r;
        };

        const unite = (a, b) => {
          let ra = find(a);
          let rb = find(b);
          if (ra === rb) return false;
          if (rank[ra] < rank[rb]) {
            parent[ra] = rb;
          } else if (rank[ra] > rank[rb]) {
            parent[rb] = ra;
          } else {
            parent[rb] = ra;
            rank[ra]++;
          }
          return true;
        };

        const edges = [];
        for (let y = 0; y < h; y++) {
          for (let x = 0; x < w; x++) {
            const i = y * w + x;
            if (x + 1 < w) edges.push([i, i + 1, 1]); // east
            if (y + 1 < h) edges.push([i, i + w, 2]); // south
          }
        }

        for (let i = edges.length - 1; i > 0; i--) {
          const j = randInt(i + 1);
          const tmp = edges[i];
          edges[i] = edges[j];
          edges[j] = tmp;
        }

        for (let k = 0; k < edges.length; k++) {
          const [a, b, di] = edges[k];
          if (unite(a, b)) maze.carve(a, b, di);
        }

        return maze;
      }

      static generateSidewinder(w, h) {
        const maze = new GridMaze(w, h);

        const idx = (x, y) => y * w + x;
        const EAST = 1;
        const NORTH = 0;

        for (let y = 0; y < h; y++) {
          let runStart = 0;
          for (let x = 0; x < w; x++) {
            const atEastBoundary = x === w - 1;
            const atNorthBoundary = y === 0;

            const carveEast = !atEastBoundary && (atNorthBoundary || Math.random() < 0.5);

            if (carveEast) {
              const a = idx(x, y);
              const b = idx(x + 1, y);
              maze.carve(a, b, EAST);
            } else {
              if (!atNorthBoundary) {
                const rx = runStart + randInt(x - runStart + 1);
                const a = idx(rx, y);
                const b = idx(rx, y - 1);
                maze.carve(a, b, NORTH);
              }
              runStart = x + 1;
            }
          }
        }

        return maze;
      }

      static generateEller(w, h) {
        const maze = new GridMaze(w, h);
        const EAST = 1;
        const SOUTH = 2;

        let nextSetId = 1;
        let sets = new Int32Array(w);
        for (let x = 0; x < w; x++) sets[x] = nextSetId++;

        const ensureSet = (x) => {
          if (sets[x] === 0) sets[x] = nextSetId++;
        };

        for (let y = 0; y < h; y++) {
          for (let x = 0; x < w; x++) ensureSet(x);

          if (y === h - 1) {
            for (let x = 0; x < w - 1; x++) {
              if (sets[x] !== sets[x + 1]) {
                const a = y * w + x;
                const b = y * w + x + 1;
                maze.carve(a, b, EAST);
                const oldId = sets[x + 1];
                const newId = sets[x];
                for (let k = 0; k < w; k++) {
                  if (sets[k] === oldId) sets[k] = newId;
                }
              }
            }
            break;
          }

          for (let x = 0; x < w - 1; x++) {
            if (sets[x] === sets[x + 1]) continue;
            if (Math.random() < 0.5) {
              const a = y * w + x;
              const b = y * w + x + 1;
              maze.carve(a, b, EAST);
              const oldId = sets[x + 1];
              const newId = sets[x];
              for (let k = 0; k < w; k++) {
                if (sets[k] === oldId) sets[k] = newId;
              }
            }
          }

          const down = new Int32Array(w);
          for (let x = 0; x < w; x++) down[x] = 0;

          let x = 0;
          while (x < w) {
            const setId = sets[x];
            let runStart = x;
            while (x < w && sets[x] === setId) x++;
            const runEnd = x - 1;

            let hasDown = false;
            for (let i = runStart; i <= runEnd; i++) {
              if (Math.random() < 0.5) {
                const a = y * w + i;
                const b = (y + 1) * w + i;
                maze.carve(a, b, SOUTH);
                down[i] = setId;
                hasDown = true;
              }
            }
            if (!hasDown) {
              const i = runStart + randInt(runEnd - runStart + 1);
              const a = y * w + i;
              const b = (y + 1) * w + i;
              maze.carve(a, b, SOUTH);
              down[i] = setId;
            }
          }

          sets = down;
        }

        return maze;
      }

      static generatePrim(w, h) {
        const maze = new GridMaze(w, h);
        const n = w * h;
        const neigh = buildNeighborTable(w, h);
        const inTree = new Uint8Array(n);
        const frontier = [];

        const start = randInt(n);
        inTree[start] = 1;
        for (const [j, di] of neigh[start]) {
          frontier.push([start, j, di]);
        }

        while (frontier.length) {
          const k = randInt(frontier.length);
          const [a, b, di] = frontier[k];
          const last = frontier.length - 1;
          frontier[k] = frontier[last];
          frontier.pop();

          if (inTree[b]) continue;
          maze.carve(a, b, di);
          inTree[b] = 1;
          for (const [j, dj] of neigh[b]) {
            if (!inTree[j]) frontier.push([b, j, dj]);
          }
        }

        return maze;
      }

      static generateBinaryTree(w, h) {
        const maze = new GridMaze(w, h);
        const EAST = 1;
        const NORTH = 0;

        for (let y = 0; y < h; y++) {
          for (let x = 0; x < w; x++) {
            const atNorth = y === 0;
            const atEast = x === w - 1;
            if (atNorth && atEast) continue;
            if (atNorth) {
              const a = y * w + x;
              const b = y * w + x + 1;
              maze.carve(a, b, EAST);
              continue;
            }
            if (atEast) {
              const a = y * w + x;
              const b = (y - 1) * w + x;
              maze.carve(a, b, NORTH);
              continue;
            }
            if (Math.random() < 0.5) {
              const a = y * w + x;
              const b = y * w + x + 1;
              maze.carve(a, b, EAST);
            } else {
              const a = y * w + x;
              const b = (y - 1) * w + x;
              maze.carve(a, b, NORTH);
            }
          }
        }

        return maze;
      }

      static generateHuntAndKill(w, h) {
        const maze = new GridMaze(w, h);
        const n = w * h;
        const neigh = buildNeighborTable(w, h);
        const visited = new Uint8Array(n);

        let current = randInt(n);
        visited[current] = 1;
        let visitedCount = 1;

        while (visitedCount < n) {
          const options = neigh[current].filter(([j]) => !visited[j]);
          if (options.length > 0) {
            const [next, di] = options[randInt(options.length)];
            maze.carve(current, next, di);
            current = next;
            visited[current] = 1;
            visitedCount++;
            continue;
          }

          let found = -1;
          for (let i = 0; i < n; i++) {
            if (visited[i]) continue;
            const opts = neigh[i].filter(([j]) => visited[j]);
            if (opts.length === 0) continue;
            const [j, di] = opts[randInt(opts.length)];
            maze.carve(i, j, di);
            visited[i] = 1;
            visitedCount++;
            found = i;
            break;
          }

          if (found === -1) break;
          current = found;
        }

        return maze;
      }

      static generateSpineBranches(w, h) {
        const maze = new GridMaze(w, h);
        const n = w * h;
        const neigh = buildNeighborTable(w, h);
        const visited = new Uint8Array(n);

        const idx = (x, y) => y * w + x;
        const toXY = (i) => [i % w, (i / w) | 0];

        const targetSpine = Math.max(2, Math.min(n, Math.floor(4 * Math.max(w, h))));
        const biasProb = 0.75; // bias toward +x, +y

        const pickBiasedNeighbor = (cur, options, biasDx, biasDy) => {
          if (options.length === 1) return options[0];
          if (Math.random() > biasProb) return options[randInt(options.length)];
          const [cx, cy] = toXY(cur);
          const preferred = [];
          for (let i = 0; i < options.length; i++) {
            const [j, di] = options[i];
            const [nx, ny] = toXY(j);
            const dx = nx - cx;
            const dy = ny - cy;
            if ((biasDx === 1 && dx > 0) || (biasDx === -1 && dx < 0) ||
                (biasDy === 1 && dy > 0) || (biasDy === -1 && dy < 0)) {
              preferred.push(options[i]);
            }
          }
          return preferred.length ? preferred[randInt(preferred.length)] : options[randInt(options.length)];
        };

        // Build a biased spine from top-left
        let current = idx(0, 0);
        visited[current] = 1;
        const spine = [current];

        while (spine.length < targetSpine) {
          const options = neigh[current].filter(([j]) => !visited[j]);
          if (options.length === 0) {
            let found = -1;
            for (let i = spine.length - 1; i >= 0; i--) {
              const v = spine[i];
              const opts = neigh[v].filter(([j]) => !visited[j]);
              if (opts.length) {
                current = v;
                found = v;
                break;
              }
            }
            if (found === -1) break;
            continue;
          }
          const [next, di] = pickBiasedNeighbor(current, options, 1, 1);
          maze.carve(current, next, di);
          current = next;
          visited[current] = 1;
          spine.push(current);
        }

        // Add a few long branches off the spine (biased to top-right or bottom-left)
        const targetBranch = Math.max(2, Math.min(n, Math.floor(Math.max(w, h))));
        const numBranches = Math.max(2, Math.round(Math.max(w, h) / 8));
        const spineCandidates = spine.slice(1, Math.max(2, spine.length - 1));

        for (let b = 0; b < numBranches && spineCandidates.length; b++) {
          const pick = randInt(spineCandidates.length);
          const start = spineCandidates[pick];
          spineCandidates[pick] = spineCandidates[spineCandidates.length - 1];
          spineCandidates.pop();

          const branchBias = Math.random() < 0.5 ? [-1, -1] : [1, -1];
          let cur = start;
          let steps = 0;
          while (steps < targetBranch) {
            const options = neigh[cur].filter(([j]) => !visited[j]);
            if (options.length === 0) break;
            const [next, di] = pickBiasedNeighbor(cur, options, branchBias[0], branchBias[1]);
            maze.carve(cur, next, di);
            cur = next;
            visited[cur] = 1;
            steps++;
          }
        }

        // Fill remaining cells using a Prim-like frontier growth
        const frontier = [];
        for (let i = 0; i < n; i++) {
          if (!visited[i]) continue;
          for (const [j, di] of neigh[i]) {
            if (!visited[j]) frontier.push([i, j, di]);
          }
        }

        while (frontier.length) {
          const k = randInt(frontier.length);
          const [a, b, di] = frontier[k];
          frontier[k] = frontier[frontier.length - 1];
          frontier.pop();

          if (visited[b]) continue;
          maze.carve(a, b, di);
          visited[b] = 1;
          for (const [j, dj] of neigh[b]) {
            if (!visited[j]) frontier.push([b, j, dj]);
          }
        }

        return maze;
      }

    }

    function randInt(n) { return (Math.random() * n) | 0; }

    function buildNeighborTable(w, h) {
      const n = w * h;
      const neigh = new Array(n);
      for (let i = 0; i < n; i++) {
        const x = i % w;
        const y = (i / w) | 0;
        const list = [];
        for (let di = 0; di < 4; di++) {
          const d = DIRS[di];
          const nx = x + d.dx, ny = y + d.dy;
          if (nx >= 0 && ny >= 0 && nx < w && ny < h) {
            list.push([ny * w + nx, di]);
          }
        }
        neigh[i] = list;
      }
      return neigh;
    }

    

    // =========================
    // Couleurs
    // =========================
    const PALETTE = [
      "#e6194b", "#3cb44b", "#4363d8", "#f58231",
      "#911eb4", "#46f0f0", "#f032e6", "#bcf60c",
      "#fabebe", "#008080", "#e6beff", "#9a6324",
    ];

    function hexToRgb(hex) {
      const h = hex.replace("#", "");
      const n = parseInt(h, 16);
      return { r: (n >> 16) & 255, g: (n >> 8) & 255, b: n & 255 };
    }

    // =========================
    // Exploration partagée : claims / visited
    // =========================
    let claimedBy = null;    // Int16Array: agentId du 1er visiteur, -1 sinon
    let claimedCount = 0;

    function resetClaims(nCells) {
      claimedBy = new Int16Array(nCells);
      claimedBy.fill(-1);
      claimedCount = 0;
    }

    function claimCell(agentId, cellIndex) {
      if (claimedBy[cellIndex] !== -1) return false;
      claimedBy[cellIndex] = agentId;
      claimedCount++;
      return true;
    }

    // =========================
    // Random DFS Agent
    // =========================
    class RandomDfsAgent {
      constructor(id, colorHex, maze, startIndex, speed = 120) {
        this.id = id;
        this.colorHex = colorHex;
        this.colorRgb = hexToRgb(colorHex);
        this.maze = maze;

        this.speed = speed;
        this.budget = 0;

        this.visited = new Uint8Array(maze.width * maze.height);
        this.stack = [startIndex];
        this.current = startIndex;
        this.done = false;

        this.visited[startIndex] = 1;
      }

      stepOnce() {
        if (this.done) return;

        if (this.stack.length === 0) {
          this.done = true;
          return;
        }

        const cur = this.stack[this.stack.length - 1];
        this.current = cur;

        const neighbors = this.maze.openNeighbors(cur);
        const candidates = [];
        for (let k = 0; k < neighbors.length; k++) {
          const j = neighbors[k];
          if (!this.visited[j]) candidates.push(j);
        }

        if (candidates.length > 0) {
          const j = candidates[randInt(candidates.length)];
          this.visited[j] = 1;
          this.stack.push(j);
          this.current = j;
          movesCount++;
          claimCell(this.id, j);
          return;
        }

        this.stack.pop();
        if (this.stack.length === 0) this.done = true;
        else {
          this.current = this.stack[this.stack.length - 1];
          movesCount++;
        }
      }
    }

    // =========================
    // LGA: Locally Greedy Agent (policy-driven)
    // =========================
    class LgaAgent {
      constructor(id, colorHex, maze, startIndex, sharedVisited, reanchorPolicy, speed = 120, useAnchorCounts = false) {
        this.id = id;
        this.colorHex = colorHex;
        this.colorRgb = hexToRgb(colorHex);
        this.maze = maze;
        this.sharedVisited = sharedVisited || null;
        this.reanchorPolicy = reanchorPolicy || null;
        this.useAnchorCounts = useAnchorCounts;

        this.speed = speed;
        this.budget = 0;

        this.visited = new Uint8Array(maze.width * maze.height);
        this.stack = [startIndex];
        this.current = startIndex;
        this.done = false;
        this.reanchoring = false;
        this.reanchorPath = null;
        this.reanchorIndex = 0;
        this.anchorNode = startIndex;

        this.visited[startIndex] = 1;
        if (this.useAnchorCounts && lgaAnchorCounts && cteTree) {
          addAnchorCounts(this.anchorNode, cteTree.parent, lgaAnchorCounts, 1);
        }
      }

      _hasUnvisitedNeighbor(i) {
        const neighbors = this.maze.openNeighbors(i);
        for (let k = 0; k < neighbors.length; k++) {
          const j = neighbors[k];
          if (this.visited[j]) continue;
          if (this.sharedVisited && this.sharedVisited[j]) continue;
          return true;
        }
        return false;
      }

      reanchor() {
        // if all cells are completed, do nothing
        if (claimedCount >= claimedBy.length) return;

        // ensure parent/depth tables
        if (!cteTree) {
          const root = this.maze.idx(0, 0);
          cteTree = buildRootedTree(this.maze, root);
        }
        if (!depthFromRoot) {
          const root = this.maze.idx(0, 0);
          depthFromRoot = computeDepths(this.maze, root);
        }

        let best = -1;
        if (this.reanchorPolicy) {
          const lambdaVal = lgaLambdaInput ? Number(lgaLambdaInput.value) : 1;
          best = this.reanchorPolicy({
            agent: this,
            maze: this.maze,
            parent: cteTree.parent,
            depth: depthFromRoot,
            claimedBy,
            lambda: lambdaVal,
            counts: lgaAnchorCounts
          });
        }
        if (best === -1 || best === null || best === undefined) return;

        if (this.useAnchorCounts && lgaAnchorCounts) {
          updateAnchorCounts(this.anchorNode, best, cteTree.parent, depthFromRoot, lgaAnchorCounts);
          this.anchorNode = best;
        }

        const path = shortestPathViaLca(this.current, best, cteTree.parent, depthFromRoot);
        if (!path || path.length === 0) return;

        this.reanchoring = true;
        this.reanchorPath = path;
        this.reanchorIndex = 0;
        this.stack = path.slice();
      }

      stepOnce() {
        if (this.done) return;

        if (this.reanchoring && this.reanchorPath) {
          if (this.reanchorIndex < this.reanchorPath.length - 1) {
            this.reanchorIndex++;
            const nxt = this.reanchorPath[this.reanchorIndex];
            this.current = nxt;
            if (!this.visited[nxt]) this.visited[nxt] = 1;
            if (this.sharedVisited) this.sharedVisited[nxt] = 1;
            movesCount++;
            claimCell(this.id, nxt);
            return;
          }
          // reached target
          this.reanchoring = false;
          this.reanchorPath = null;
          this.reanchorIndex = 0;
          this.stack = [this.current];
        }

        if (this.stack.length === 0) {
          if (!this._hasUnvisitedNeighbor(this.current)) {
            this.reanchor();
          } else {
            this.stack = [this.current];
          }
          return;
        }

        const cur = this.stack[this.stack.length - 1];
        this.current = cur;

        const neighbors = this.maze.openNeighbors(cur);
        const candidates = [];
        for (let k = 0; k < neighbors.length; k++) {
          const j = neighbors[k];
          if (this.visited[j]) continue;
          if (this.sharedVisited && this.sharedVisited[j]) continue;
          candidates.push(j);
        }

        if (candidates.length > 0) {
          const j = candidates[randInt(candidates.length)];
          this.visited[j] = 1;
          if (this.sharedVisited) this.sharedVisited[j] = 1;
          this.stack.push(j);
          this.current = j;
          movesCount++;
          claimCell(this.id, j);
          return;
        }

        this.stack.pop();
        if (this.stack.length === 0) {
          if (!this._hasUnvisitedNeighbor(this.current)) {
            this.reanchor();
          } else {
            this.stack = [this.current];
          }
          return;
        }
        this.current = this.stack[this.stack.length - 1];
        movesCount++;
      }
    }

    // =========================
    // CTE : arbre enraciné + compteurs
    // =========================
    // On construit un arbre enraciné à root (0,0). Comme le labyrinthe est un arbre, on obtient parent/children.
    function buildRootedTree(maze, root) {
      const n = maze.width * maze.height;
      const parent = new Int32Array(n).fill(-1);
      const order = [];                 // ordre BFS/DFS (pour éventuellement faire des passes)
      const children = Array.from({ length: n }, () => []);

      const q = [root];
      parent[root] = root;
      while (q.length) {
        const v = q.pop();
        order.push(v);
        const neigh = maze.openNeighbors(v);
        for (const u of neigh) {
          if (parent[u] !== -1) continue;
          parent[u] = v;
          children[v].push(u);
          q.push(u);
        }
      }
      parent[root] = -1;
      return { parent, children, order };
    }

    // Compute depth (distance to root) for all nodes with BFS
    function computeDepths(maze, root) {
      const n = maze.width * maze.height;
      const depth = new Int32Array(n).fill(-1);
      const q = new Int32Array(n);
      let head = 0;
      let tail = 0;
      depth[root] = 0;
      q[tail++] = root;

      while (head < tail) {
        const v = q[head++];
        const neigh = maze.openNeighbors(v);
        for (let k = 0; k < neigh.length; k++) {
          const u = neigh[k];
          if (depth[u] !== -1) continue;
          depth[u] = depth[v] + 1;
          q[tail++] = u;
        }
      }
      return depth;
    }

    // Frontier helpers: a node is frontier if visited and has an unvisited neighbor
    function isFrontierNode(i, maze, visited) {
      if (!visited || !visited[i]) return false;
      const neigh = maze.openNeighbors(i);
      for (let k = 0; k < neigh.length; k++) {
        if (!visited[neigh[k]]) return true;
      }
      return false;
    }

    function listFrontierNodes(maze, visited) {
      if (!visited) return [];
      const n = maze.width * maze.height;
      const res = [];
      for (let i = 0; i < n; i++) {
        if (isFrontierNode(i, maze, visited)) res.push(i);
      }
      return res;
    }

    // Frontier using claimedBy (global explored by any agent)
    function isFrontierNodeClaimed(i, maze, claimedBy) {
      if (!claimedBy || claimedBy[i] === -1) return false;
      const neigh = maze.openNeighbors(i);
      for (let k = 0; k < neigh.length; k++) {
        if (claimedBy[neigh[k]] === -1) return true;
      }
      return false;
    }

    // Shortest path between u and v in a tree using LCA + parent/depth
    function shortestPathViaLca(u, v, parent, depth) {
      const lca = lowestCommonAncestor(u, v, parent, depth);
      if (lca === -1) return [u];
      const path = [];
      let x = u;
      while (x !== lca) {
        path.push(x);
        x = parent[x];
      }
      path.push(lca);
      const tail = [];
      x = v;
      while (x !== lca) {
        tail.push(x);
        x = parent[x];
      }
      for (let i = tail.length - 1; i >= 0; i--) path.push(tail[i]);
      return path;
    }

    function distanceViaLca(u, v, parent, depth) {
      const lca = lowestCommonAncestor(u, v, parent, depth);
      if (lca === -1) return Infinity;
      return depth[u] + depth[v] - 2 * depth[lca];
    }

    function updateAnchorCounts(prev, next, parent, depth, counts) {
      if (!counts || prev === null || next === null || prev < 0 || next < 0) return;
      const a = lowestCommonAncestor(prev, next, parent, depth);
      if (a === -1) return;
      let x = prev;
      while (x !== a) {
        counts[x] -= 1;
        x = parent[x];
      }
      let y = next;
      while (y !== a) {
        counts[y] += 1;
        y = parent[y];
      }
      // Keep LCA unchanged to preserve counts for common ancestors
    }

    function addAnchorCounts(node, parent, counts, delta = 1) {
      let x = node;
      while (x !== -1) {
        counts[x] += delta;
        x = parent[x];
      }
    }

    // XuMinusXv(u,v) = sum x[i] along path u->LCA (excluding LCA)
    //                - sum x[i] along path v->LCA (excluding LCA)
    function XuMinusXv(u, v, parent, depth, counts) {
      if (!counts) return Infinity;
      const a = lowestCommonAncestor(u, v, parent, depth);
      if (a === -1) return Infinity;
      let sumU = 0;
      let x = u;
      while (x !== a) {
        sumU += counts[x];
        x = parent[x];
      }
      let sumV = 0;
      let y = v;
      while (y !== a) {
        sumV += counts[y];
        y = parent[y];
      }
      return sumU - sumV;
    }

    function XuLogXuMinusXvLogXv(u, v, parent, depth, counts) {
      if (!counts) return Infinity;
      const a = lowestCommonAncestor(u, v, parent, depth);
      if (a === -1) return Infinity;
      const xlogx = (x) => (x <= 0 ? 0 : x * Math.log(x));
      let sumU = 0;
      let x = u;
      while (x !== a) {
        sumU += xlogx(counts[x]);
        x = parent[x];
      }
      let sumV = 0;
      let y = v;
      while (y !== a) {
        sumV += xlogx(counts[y]);
        y = parent[y];
      }
      return sumU - sumV;
    }

    // LGA reanchor policies
    function lgaPolicyShallowestFrontier({ maze, depth, claimedBy }) {
      let best = -1;
      let bestDepth = Infinity;
      for (let i = 0; i < claimedBy.length; i++) {
        if (!isFrontierNodeClaimed(i, maze, claimedBy)) continue;
        const d = depth[i];
        if (d >= 0 && d < bestDepth) {
          bestDepth = d;
          best = i;
        }
      }
      return best;
    }

    function lgaPolicyLambdaDepthDistance({ agent, maze, parent, depth, claimedBy, lambda }) {
      const lam = Number.isFinite(lambda) ? lambda : 1;
      let best = -1;
      let bestScore = Infinity;
      for (let i = 0; i < claimedBy.length; i++) {
        if (!isFrontierNodeClaimed(i, maze, claimedBy)) continue;
        const dRoot = depth[i];
        if (dRoot < 0) continue;
        const dist = distanceViaLca(agent.current, i, parent, depth);
        const score = lam * dRoot + dist;
        if (score < bestScore) {
          bestScore = score;
          best = i;
        }
      }
      return best;
    }

    function lgaPolicyXuMinusXv({ agent, maze, parent, depth, claimedBy, counts }) {
      let best = -1;
      let bestScore = -Infinity;
      for (let i = 0; i < claimedBy.length; i++) {
        if (!isFrontierNodeClaimed(i, maze, claimedBy)) continue;
        const dist = distanceViaLca(agent.current, i, parent, depth);
        const score = XuMinusXv(agent.current, i, parent, depth, counts) - depth[i] - dist;
        if (score > bestScore) {
          bestScore = score;
          best = i;
        }
      }
      return best;
    }

    function lgaPolicyXuLogXuMinusXvLogXv({ agent, maze, parent, depth, claimedBy, counts }) {
      let best = -1;
      let bestScore = -Infinity;
      for (let i = 0; i < claimedBy.length; i++) {
        if (!isFrontierNodeClaimed(i, maze, claimedBy)) continue;
        const dist = distanceViaLca(agent.current, i, parent, depth);
        const score = XuLogXuMinusXvLogXv(agent.current, i, parent, depth, counts) - depth[i] - dist;
        if (score > bestScore) {
          bestScore = score;
          best = i;
        }
      }
      return best;
    }

    // Lowest Common Ancestor using parent + depth (O(depth(u)+depth(v)))
    function lowestCommonAncestor(u, v, parent, depth) {
      if (!parent || !depth) return -1;
      if (u < 0 || v < 0) return -1;
      if (depth[u] < 0 || depth[v] < 0) return -1;

      let a = u;
      let b = v;

      while (depth[a] > depth[b]) a = parent[a];
      while (depth[b] > depth[a]) b = parent[b];

      while (a !== b) {
        a = parent[a];
        b = parent[b];
        if (a === -1 || b === -1) return -1;
      }
      return a;
    }

    // Etat partagé CTE
    class CteShared {
      constructor(nCells) {
        this.n = nCells;
        this.subtreeAgents = new Int32Array(nCells); // #agents dans le sous-arbre du node
        this.subtreeDone = new Uint8Array(nCells);   // 0/1
        this.visited = new Uint8Array(nCells);       // 0/1 (exploration globale)
        this.visitedCount = 0;
      }

      // Met à jour subtreeAgents le long des ancêtres d'un node (inclu) : delta = +1 ou -1
      addAgentAlongAncestors(node, parent, delta) {
        let v = node;
        while (v !== -1) {
          this.subtreeAgents[v] += delta;
          v = parent[v];
        }
      }

      markVisited(node) {
        if (this.visited[node]) return false;
        this.visited[node] = 1;
        this.visitedCount++;
        return true;
      }

      // recalcul local "done" : un node est done si
      // - il est visité
      // - et tous ses enfants sont done
      tryUpdateDone(node, parent, children) {
        // remonte tant qu'on peut (amortized OK)
        let v = node;
        while (v !== -1) {
          if (!this.visited[v]) return;
          const ch = children[v];
          for (let i = 0; i < ch.length; i++) {
            if (!this.subtreeDone[ch[i]]) return;
          }
          if (this.subtreeDone[v]) return; // déjà done, stop
          this.subtreeDone[v] = 1;
          v = parent[v];
        }
      }

      allDone() {
        return this.visitedCount >= this.n;
      }
    }

    // =========================
    // OPT: Deterministic DFS path builder (includes backtracking)
    // =========================
    function buildDfsPath(maze, root) {
      const n = maze.width * maze.height;
      const visited = new Uint8Array(n);
      const path = [];

      function dfs(v) {
        visited[v] = 1;
        path.push(v);
        const neighbors = maze.openNeighbors(v);
        // Sort neighbors by index for deterministic order
        neighbors.sort((a, b) => a - b);
        for (const u of neighbors) {
          if (!visited[u]) {
            dfs(u);
            // Backtrack: return to v after exploring subtree rooted at u
            path.push(v);
          }
        }
      }

      dfs(root);
      return path;
    }

    // OPT Agent: navigate to chunk start, then DFS explore the chunk
    class OptAgent {
      constructor(id, colorHex, maze, root, path, chunkStartIdx, chunkEndIdx, speed = 120) {
        this.id = id;
        this.colorHex = colorHex;
        this.colorRgb = hexToRgb(colorHex);
        this.maze = maze;

        this.speed = speed;
        this.budget = 0;

        this.current = root;
        this.done = false;

        // Chunk nodes: set of nodes in the agent's assigned chunk
        this.chunkNodes = new Set(path.slice(chunkStartIdx, chunkEndIdx));
        this.chunkStartNode = path[chunkStartIdx];

        // Phase 1: navigate to chunk start using shortest path (BFS)
        this.phase = "navigate";
        this.shortestPath = this._computeShortestPath(root, this.chunkStartNode);
        this.pathIndex = 0;

        claimCell(this.id, root);
      }

      _computeShortestPath(from, to) {
        const n = this.maze.width * this.maze.height;
        const parent = new Int32Array(n).fill(-1);
        const q = [from];
        parent[from] = from;

        while (q.length) {
          const v = q.shift();
          if (v === to) break;
          const neighbors = this.maze.openNeighbors(v);
          for (const u of neighbors) {
            if (parent[u] === -1) {
              parent[u] = v;
              q.push(u);
            }
          }
        }

        // Reconstruct path from 'from' to 'to'
        const path = [];
        let v = to;
        while (v !== from) {
          path.unshift(v);
          v = parent[v];
        }
        path.unshift(from);
        return path;
      }

      stepOnce() {
        if (this.done) return;

        if (this.phase === "navigate") {
          // Move along shortest path to chunk start
          if (this.pathIndex < this.shortestPath.length - 1) {
            this.pathIndex++;
            this.current = this.shortestPath[this.pathIndex];
            movesCount++;
            claimCell(this.id, this.current);
          } else {
            // Reached chunk start, switch to DFS exploration
            this.phase = "explore";
            this.visited = new Uint8Array(this.maze.width * this.maze.height);
            this.stack = [this.chunkStartNode];
            this.visited[this.chunkStartNode] = 1;
            this.current = this.chunkStartNode;
          }
        } else if (this.phase === "explore") {
          // DFS exploration within chunk
          if (this.stack.length === 0) {
            this.done = true;
            return;
          }

          const cur = this.stack[this.stack.length - 1];
          this.current = cur;

          const neighbors = this.maze.openNeighbors(cur);
          const candidates = [];
          for (const j of neighbors) {
            if (!this.visited[j] && this.chunkNodes.has(j)) {
              candidates.push(j);
            }
          }

          if (candidates.length > 0) {
            const j = candidates[randInt(candidates.length)];
            this.visited[j] = 1;
            this.stack.push(j);
            this.current = j;
            movesCount++;
            claimCell(this.id, j);
          } else {
            this.stack.pop();
            if (this.stack.length > 0) {
              // Backtrack one step
              this.current = this.stack[this.stack.length - 1];
              movesCount++;
            } else {
              this.done = true;
            }
            return;
          }
        }
      }
    }

    class CteAgent {
      constructor(id, colorHex, maze, root, parent, children, shared, speed = 120) {
        this.id = id;
        this.colorHex = colorHex;
        this.colorRgb = hexToRgb(colorHex);
        this.maze = maze;

        this.root = root;
        this.parent = parent;
        this.children = children;
        this.shared = shared;

        this.speed = speed;
        this.budget = 0;

        this.current = root;
        this.done = false;

        // cet agent compte dans les sous-arbres des ancêtres du root (juste root ici)
        shared.addAgentAlongAncestors(root, parent, +1);

        // visite root globalement + claim (si personne ne l’a fait)
        if (shared.markVisited(root)) {
          claimCell(this.id, root);
          shared.tryUpdateDone(root, parent, children);
        }
      }

      // Choix à l'intersection :
      // - si tous les enfants sont done => remonter
      // - sinon choisir un enfant non-done avec subtreeAgents minimal (tie-break aléatoire)
      stepOnce() {
        if (this.done) return;
        if (this.shared.allDone()) { this.done = true; return; }

        const v = this.current;
        const ch = this.children[v];

        // Si aucun enfant : feuille => remonte
        // Si tous les enfants done => remonte
        let best = -1;
        let bestLoad = Infinity;
        let ties = [];

        for (let i = 0; i < ch.length; i++) {
          const u = ch[i];
          if (this.shared.subtreeDone[u]) continue;
          const load = this.shared.subtreeAgents[u];
          if (load < bestLoad) {
            bestLoad = load;
            ties = [u];
          } else if (load === bestLoad) {
            ties.push(u);
          }
        }

        let next;
        if (ties.length > 0) {
          next = ties[randInt(ties.length)];
        } else {
          // remonter
          next = this.parent[v];
          if (next === -1) {
            // on est à la racine : si rien à faire, stop
            this.done = true;
            return;
          }
        }

        // déplacement : mise à jour subtreeAgents le long des ancêtres
        this.shared.addAgentAlongAncestors(this.current, this.parent, -1);
        this.current = next;
        movesCount++;
        this.shared.addAgentAlongAncestors(this.current, this.parent, +1);

        // si on arrive sur un nœud non encore visité globalement => le marquer + claim couleur
        if (this.shared.markVisited(this.current)) {
          claimCell(this.id, this.current);
        }

        // mise à jour des flags done (peut remonter)
        this.shared.tryUpdateDone(this.current, this.parent, this.children);

        if (this.shared.allDone()) this.done = true;
      }
    }

    // =========================
    // Rendu
    // =========================
    // Canvas sizing (default target size)
    function fitCanvas(canvas, targetCssPx = 900) {
      const dpr = window.devicePixelRatio || 1;
      const parentW = (canvas.parentElement && canvas.parentElement.clientWidth) || document.body.clientWidth;
      const cssW = Math.min(targetCssPx, Math.max(100, Math.floor(parentW - 32)));
      const cssH = cssW;

      canvas.style.width = cssW + "px";
      canvas.style.height = cssH + "px";
      canvas.width = Math.floor(cssW * dpr);
      canvas.height = Math.floor(cssH * dpr);

      const ctx = canvas.getContext("2d");
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      return { ctx, cssW, cssH };
    }

    function draw(canvas, maze, claimedBy, agents) {
      const { ctx, cssW, cssH } = fitCanvas(canvas);

      const w = maze.width, h = maze.height;
      const pad = 10;
      const cell = Math.min((cssW - 2 * pad) / w, (cssH - 2 * pad) / h);

      ctx.clearRect(0, 0, cssW, cssH);
      ctx.fillStyle = "#fff";
      ctx.fillRect(0, 0, cssW, cssH);

      const ox = pad, oy = pad;

      // optional: show frontier nodes
      try {
        const showFrontier = document.getElementById('chkShowFrontier')?.checked;
        if (showFrontier) {
          if (claimedBy) {
            ctx.fillStyle = 'rgba(0, 90, 0, 0.45)';
            for (let idx = 0; idx < claimedBy.length; idx++) {
              if (!isFrontierNodeClaimed(idx, maze, claimedBy)) continue;
              const x = idx % w;
              const y = (idx / w) | 0;
              ctx.fillRect(ox + x * cell, oy + y * cell, cell, cell);
            }
          }
        }
      } catch (e) {
        // defensive: ignore if checkbox missing
      }

      // optional: show anchor counts x[i]
      try {
        const showX = document.getElementById('chkShowAnchorCounts')?.checked;
        if (showX && lgaAnchorCounts) {
          ctx.fillStyle = 'rgba(0,0,0,0.8)';
          ctx.font = `${Math.max(8, Math.floor(cell * 0.35))}px system-ui, -apple-system, Segoe UI, Roboto, sans-serif`;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          for (let i = 0; i < lgaAnchorCounts.length; i++) {
            const val = lgaAnchorCounts[i];
            if (val === 0) continue;
            const x = i % w;
            const y = (i / w) | 0;
            const cx = ox + x * cell + cell * 0.5;
            const cy = oy + y * cell + cell * 0.5;
            ctx.fillText(String(val), cx, cy);
          }
        }
      } catch (e) {
        // defensive: ignore if checkbox missing
      }

      // optional: highlight nodes at a given depth
      try {
        const highlightDepth = document.getElementById('chkHighlightDepth')?.checked;
        const depthInput = document.getElementById('depthLevel');
        const depthTarget = depthInput ? Number(depthInput.value) : NaN;
        if (highlightDepth && depthFromRoot && Number.isFinite(depthTarget)) {
          ctx.fillStyle = 'rgba(255, 200, 0, 0.35)';
          for (let i = 0; i < depthFromRoot.length; i++) {
            if (depthFromRoot[i] !== depthTarget) continue;
            const x = i % w;
            const y = (i / w) | 0;
            ctx.fillRect(ox + x * cell, oy + y * cell, cell, cell);
          }
        }
      } catch (e) {
        // defensive: if checkbox/input not present or depth missing, ignore
      }

      // optional: shade nodes not yet visited (all algos)
      try {
        const shadeUnvisited = document.getElementById('chkShadeUnvisited')?.checked;
        if (shadeUnvisited && claimedBy) {
          ctx.fillStyle = 'rgba(0,0,0,0.6)';
          for (let i = 0; i < claimedBy.length; i++) {
            if (claimedBy[i] !== -1) continue;
            const x = i % w;
            const y = (i / w) | 0;
            ctx.fillRect(ox + x * cell, oy + y * cell, cell, cell);
          }
        }
      } catch (e) {
        // defensive: if checkbox not present or claimedBy missing, ignore
      }

      // optional: shade nodes whose subtree is fully done (CTE)
      try {
        const shade = document.getElementById('chkShadeDoneSubtrees')?.checked;
        if (shade && cteShared) {
          ctx.fillStyle = 'rgba(0,0,0,0.22)';
          for (let i = 0; i < cteShared.n; i++) {
            if (cteShared.subtreeDone[i]) {
              const x = i % w;
              const y = (i / w) | 0;
              ctx.fillRect(ox + x * cell, oy + y * cell, cell, cell);
            }
          }
        }
      } catch (e) {
        // defensive: if checkbox not present or cteShared missing, ignore
      }

      // claims
      for (let i = 0; i < claimedBy.length; i++) {
        const aId = claimedBy[i];
        if (aId < 0) continue;
        const a = agents[aId];
        if (!a) continue;

        const x = i % w;
        const y = (i / w) | 0;
        ctx.fillStyle = `rgba(${a.colorRgb.r}, ${a.colorRgb.g}, ${a.colorRgb.b}, 0.18)`;
        ctx.fillRect(ox + x * cell, oy + y * cell, cell, cell);
      }

      // murs
      ctx.lineWidth = Math.max(1, cell * 0.08);
      ctx.lineCap = "square";
      ctx.strokeStyle = "#111";

      const px = ox + 0.5;
      const py = oy + 0.5;

      ctx.beginPath();
      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
          const i = y * w + x;
          const m = maze.walls[i];
          const x0 = px + x * cell;
          const y0 = py + y * cell;
          const x1 = x0 + cell;
          const y1 = y0 + cell;

          if (m & N) { ctx.moveTo(x0, y0); ctx.lineTo(x1, y0); }
          if (m & W) { ctx.moveTo(x0, y0); ctx.lineTo(x0, y1); }
          if (x === w - 1 && (m & E)) { ctx.moveTo(x1, y0); ctx.lineTo(x1, y1); }
          if (y === h - 1 && (m & S)) { ctx.moveTo(x0, y1); ctx.lineTo(x1, y1); }
        }
      }
      ctx.stroke();

      // debug path (longest path)
      if (debugPath && debugPath.length > 0) {
        ctx.strokeStyle = "#ff0000";
        ctx.lineWidth = Math.max(2, cell * 0.15);
        ctx.lineCap = "round";
        ctx.lineJoin = "round";
        ctx.beginPath();
        for (let k = 0; k < debugPath.length; k++) {
          const i = debugPath[k];
          const x = i % w;
          const y = (i / w) | 0;
          const cx = ox + x * cell + cell * 0.5;
          const cy = oy + y * cell + cell * 0.5;
          if (k === 0) ctx.moveTo(cx, cy);
          else ctx.lineTo(cx, cy);
        }
        ctx.stroke();
      }

      // debug LCA markers
      try {
        const showLca = document.getElementById('chkShowLca')?.checked;
        if (showLca && debugLcaU !== null && debugLcaV !== null) {
          const markCell = (i, color) => {
            if (i === null || i < 0) return;
            const x = i % w;
            const y = (i / w) | 0;
            ctx.fillStyle = color;
            ctx.fillRect(ox + x * cell, oy + y * cell, cell, cell);
          };
          markCell(debugLcaU, 'rgba(160, 30, 30, 0.5)');
          markCell(debugLcaV, 'rgba(160, 30, 30, 0.5)');
          markCell(debugLca, 'rgba(30, 80, 200, 0.5)');
        }
      } catch (e) {
        // defensive: ignore if inputs missing
      }

      // agents
      for (const a of agents) {
        const i = a.current;
        const x = i % w;
        const y = (i / w) | 0;

        const cx = ox + x * cell + cell * 0.5;
        const cy = oy + y * cell + cell * 0.5;
        const r = Math.max(3, cell * 0.18);

        ctx.fillStyle = `rgba(${a.colorRgb.r}, ${a.colorRgb.g}, ${a.colorRgb.b}, 0.25)`;
        ctx.beginPath();
        ctx.arc(cx, cy, r * 1.6, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = a.colorHex;
        ctx.beginPath();
        ctx.arc(cx, cy, r, 0, Math.PI * 2);
        ctx.fill();

        ctx.strokeStyle = "rgba(255,255,255,0.9)";
        ctx.lineWidth = Math.max(1, cell * 0.06);
        ctx.beginPath();
        ctx.arc(cx, cy, r, 0, Math.PI * 2);
        ctx.stroke();
      }

      // marqueur départ (haut gauche)
      ctx.fillStyle = "rgba(0,0,0,0.6)";
      const sx = 0, sy = 0;
      ctx.beginPath();
      ctx.arc(ox + sx * cell + cell * 0.25, oy + sy * cell + cell * 0.25, Math.max(2, cell * 0.12), 0, Math.PI * 2);
      ctx.fill();
    }

    // =========================
    // UI agents
    // =========================
    const sizeInput = document.getElementById("size");
    const algoSelect = document.getElementById("algo");
    const allSpeedInput = document.getElementById("allSpeed");
    const allSpeedVal = document.getElementById("allSpeedVal");
    const btnGenerate = document.getElementById("generate");
    const btnRestart = document.getElementById("restart");
    const agentCountInput = document.getElementById("agentCount");
    const agentsPanel = document.getElementById("agentsPanel");
    const canvas = document.getElementById("canvas");
    const lcaUInput = document.getElementById("lcaU");
    const lcaVInput = document.getElementById("lcaV");
    const lgaLambdaInput = document.getElementById("lgaLambda");

    let maze = null;
    let agents = [];
    let lastT = performance.now();
    // throttle UI text updates (ms)
    let lastUiUpdate = 0;
    let debugPath = null; // path to render in red for debugging
    let movesCount = 0; // shared counter for agent moves

    // Timer state (ms)
    const timerValEl = document.getElementById("timerVal");
    let timerRunning = false;
    let timerElapsed = 0; // milliseconds

    // CTE-only shared + rooted tree
    let cteTree = null;     // { parent, children, order }
    let cteShared = null;   // CteShared
    let depthFromRoot = null; // Int32Array or null
    let lgaSharedVisited = null; // Uint8Array or null
    let lgaAnchorCounts = null; // Int32Array or null
    let debugLcaU = null;
    let debugLcaV = null;
    let debugLca = null;

    // Expose for debugging in console
    const debugVars = {
      get maze() { return maze; },
      get agents() { return agents; },
      get cteTree() { return cteTree; },
      get cteShared() { return cteShared; },
      get depthFromRoot() { return depthFromRoot; },
      lca(u, v) {
        if (!maze) return -1;
        if (!cteTree) {
          const root = maze.idx(0, 0);
          cteTree = buildRootedTree(maze, root);
        }
        if (!depthFromRoot) {
          const root = maze.idx(0, 0);
          depthFromRoot = computeDepths(maze, root);
        }
        return lowestCommonAncestor(u, v, cteTree.parent, depthFromRoot);
      }
    };
    window._debug = debugVars;

    function updateLcaDebug() {
      if (!maze || !lcaUInput || !lcaVInput) {
        debugLcaU = null;
        debugLcaV = null;
        debugLca = null;
        return;
      }
      const n = maze.width * maze.height;
      const u = Number(lcaUInput.value);
      const v = Number(lcaVInput.value);
      if (!Number.isFinite(u) || !Number.isFinite(v) || u < 0 || v < 0 || u >= n || v >= n) {
        debugLcaU = null;
        debugLcaV = null;
        debugLca = null;
        return;
      }
      debugLcaU = u | 0;
      debugLcaV = v | 0;
      debugLca = debugVars.lca(debugLcaU, debugLcaV);
    }

    // Find the deepest node and return the longest path from root to that node
    function findLongestPath(mazeObj, root) {
      const n = mazeObj.width * mazeObj.height;
      const depth = new Int32Array(n).fill(-1);
      const parent = new Int32Array(n).fill(-1);
      const q = [root];
      depth[root] = 0;
      parent[root] = -1;

      let deepestNode = root;
      let maxDepth = 0;

      while (q.length) {
        const v = q.shift();
        if (depth[v] > maxDepth) {
          maxDepth = depth[v];
          deepestNode = v;
        }
        const neighbors = mazeObj.openNeighbors(v);
        for (const u of neighbors) {
          if (depth[u] === -1) {
            depth[u] = depth[v] + 1;
            parent[u] = v;
            q.push(u);
          }
        }
      }

      // Reconstruct path from root to deepestNode
      const path = [];
      let v = deepestNode;
      while (v !== -1) {
        path.unshift(v);
        v = parent[v];
      }
      return path;
    }

    function buildAgentsUI() {
      agentsPanel.innerHTML = "";

      const header = document.createElement("div");
      header.className = "small";
      header.textContent = "Agent speeds :";
      agentsPanel.appendChild(header);

      agents.forEach((a) => {
        const row = document.createElement("div");
        row.className = "agentRow";

        const sw = document.createElement("div");
        sw.className = "swatch";
        sw.style.background = a.colorHex;

        const name = document.createElement("span");
        name.textContent = `Agent ${a.id + 1}`;
        name.style.fontWeight = "600";

        const slider = document.createElement("input");
        slider.type = "range";
        slider.min = "0";
        slider.max = "99";
        slider.step = "1";
        slider.value = String(a.speed);

        const valPill = document.createElement("span");
        valPill.className = "pill";
        valPill.textContent = `${a.speed} / s`;

        slider.addEventListener("input", () => {
          a.speed = Number(slider.value) || 0;
          valPill.textContent = `${a.speed} / s`;
          // keep global slider value in sync if all agents share the same speed
          if (allSpeedInput) {
            const rows = agentsPanel.querySelectorAll('.agentRow');
            let same = true;
            for (let i = 0; i < rows.length; i++) {
              const s = rows[i].querySelector('input[type="range"]');
              if (!s) continue;
              if (Number(s.value) !== a.speed) { same = false; break; }
            }
            if (same) {
              allSpeedInput.value = String(a.speed);
              if (allSpeedVal) allSpeedVal.textContent = `${a.speed} / s`;
            }
          }
        });

        const status = document.createElement("span");
        status.className = "small";
        status.textContent = a.done ? "✓ terminé" : "… explore";
        row._statusEl = status;

        row.appendChild(sw);
        row.appendChild(name);
        row.appendChild(slider);
        row.appendChild(valPill);
        row.appendChild(status);
        agentsPanel.appendChild(row);
      });
    }

    // global all-speed slider: set every agent speed and update UI
    if (allSpeedInput) {
      allSpeedInput.addEventListener('input', () => {
        const v = Number(allSpeedInput.value) || 0;
        if (allSpeedVal) allSpeedVal.textContent = `${v} / s`;
        agents.forEach(a => { a.speed = v; });
        const rows = agentsPanel.querySelectorAll('.agentRow');
        rows.forEach(row => {
          const s = row.querySelector('input[type="range"]');
          const pill = row.querySelector('.pill');
          if (s) s.value = String(v);
          if (pill) pill.textContent = `${v} / s`;
        });
      });
    }

    function updateAgentsStatusUI() {
      const rows = agentsPanel.querySelectorAll(".agentRow");
      rows.forEach((row, i) => {
        const statusEl = row._statusEl;
        if (!statusEl) return;
        statusEl.textContent = agents[i].done ? "✓ terminé" : "… explore";
      });
    }

    // =========================
    // Construction des agents selon algo
    // =========================
    function createAgents(count, algo) {
      const nCells = maze.width * maze.height;
      // read speeds from existing sliders in the UI so speeds persist across restarts/algo changes
      // fallback to the current `agents` array speeds if sliders are not present
      let prevSpeeds = agents.map(a => a.speed);
      const sliders = agentsPanel.querySelectorAll('input[type="range"]');
      if (sliders && sliders.length > 0) prevSpeeds = Array.from(sliders).map(s => {
        const v = Number(s.value);
        return Number.isFinite(v) ? v : 20;
      });
      resetClaims(nCells);

      const start = maze.idx(0, 0); // haut gauche pour tous
      agents = [];

      if (algo === "cte") {
        // construire arbre enraciné + shared
        cteTree = buildRootedTree(maze, start);
        cteShared = new CteShared(nCells);
        lgaSharedVisited = null;

        for (let i = 0; i < count; i++) {
          const color = PALETTE[i % PALETTE.length];
          const speed = prevSpeeds[i] ?? 20;
          const a = new CteAgent(i, color, maze, start, cteTree.parent, cteTree.children, cteShared, speed);
          agents.push(a);
        }
      } else if (algo === "opt") {
        // OPT: deterministic DFS path divided into chunks
        cteTree = null;
        cteShared = null;
        lgaSharedVisited = null;

        const path = buildDfsPath(maze, start);
        const pathLen = path.length;
        const chunkSize = Math.ceil(pathLen / count);

        for (let i = 0; i < count; i++) {
          const color = PALETTE[i % PALETTE.length];
          const speed = prevSpeeds[i] ?? 20;
          const chunkStart = i * chunkSize;
          const chunkEnd = Math.min((i + 1) * chunkSize, pathLen);
          const a = new OptAgent(i, color, maze, start, path, chunkStart, chunkEnd, speed);
          agents.push(a);
        }
      } else if (algo === "lga") {
        cteTree = null;
        cteShared = null;
        lgaSharedVisited = new Uint8Array(nCells);
        lgaSharedVisited[start] = 1;
        lgaAnchorCounts = null;

        for (let i = 0; i < count; i++) {
          const color = PALETTE[i % PALETTE.length];
          const speed = prevSpeeds[i] ?? 20;
          const a = new LgaAgent(i, color, maze, start, lgaSharedVisited, lgaPolicyShallowestFrontier, speed, false);
          claimCell(a.id, start);
          agents.push(a);
        }
      } else if (algo === "lga2") {
        cteTree = null;
        cteShared = null;
        lgaSharedVisited = new Uint8Array(nCells);
        lgaSharedVisited[start] = 1;
        lgaAnchorCounts = null;

        for (let i = 0; i < count; i++) {
          const color = PALETTE[i % PALETTE.length];
          const speed = prevSpeeds[i] ?? 20;
          const a = new LgaAgent(i, color, maze, start, lgaSharedVisited, lgaPolicyLambdaDepthDistance, speed, false);
          claimCell(a.id, start);
          agents.push(a);
        }
      } else if (algo === "lga3") {
        cteTree = buildRootedTree(maze, start);
        depthFromRoot = computeDepths(maze, start);
        cteShared = null;
        lgaSharedVisited = new Uint8Array(nCells);
        lgaSharedVisited[start] = 1;
        lgaAnchorCounts = new Int32Array(nCells);

        for (let i = 0; i < count; i++) {
          const color = PALETTE[i % PALETTE.length];
          const speed = prevSpeeds[i] ?? 20;
          const a = new LgaAgent(i, color, maze, start, lgaSharedVisited, lgaPolicyXuMinusXv, speed, true);
          claimCell(a.id, start);
          agents.push(a);
        }
      } else if (algo === "lga4") {
        cteTree = buildRootedTree(maze, start);
        depthFromRoot = computeDepths(maze, start);
        cteShared = null;
        lgaSharedVisited = new Uint8Array(nCells);
        lgaSharedVisited[start] = 1;
        lgaAnchorCounts = new Int32Array(nCells);

        for (let i = 0; i < count; i++) {
          const color = PALETTE[i % PALETTE.length];
          const speed = prevSpeeds[i] ?? 20;
          const a = new LgaAgent(i, color, maze, start, lgaSharedVisited, lgaPolicyXuLogXuMinusXvLogXv, speed, true);
          claimCell(a.id, start);
          agents.push(a);
        }
      } else {
        // random dfs (local)
        cteTree = null;
        cteShared = null;
        lgaSharedVisited = null;
        lgaAnchorCounts = null;

        for (let i = 0; i < count; i++) {
          const color = PALETTE[i % PALETTE.length];
          const speed = prevSpeeds[i] ?? 20;
          const a = new RandomDfsAgent(i, color, maze, start, speed);
          // claim start
          claimCell(a.id, start);
          agents.push(a);
        }
      }

      buildAgentsUI();
      draw(canvas, maze, claimedBy, agents);

      lastT = performance.now();
      agents.forEach(a => a.budget = 0);
      movesCount = 0;  // reset moves counter

      // restart timer when agents are (re)created
      timerElapsed = 0;
      timerRunning = agents.length > 0;
      if (timerValEl) timerValEl.textContent = `${(timerElapsed / 1000).toFixed(2)} s`;
    }

    function restartExploration() {
      if (!maze) return;
      const count = agents.length || Math.max(1, Math.min(30, Number(agentCountInput.value) || 1));
      createAgents(count, algoSelect.value);
    }

    function generateNewMaze() {
      let n = Number(sizeInput.value);
      if (!Number.isFinite(n)) n = 30;
      n = Math.max(2, Math.min(500, Math.floor(n)));

      const gen = document.getElementById('generator')?.value || 'wilson';
      if (gen === 'dfs') maze = GridMaze.generateDfs(n, n);
      else if (gen === 'comb') maze = GridMaze.generateComb(n, n);
      else if (gen === 'kruskal') maze = GridMaze.generateKruskal(n, n);
      else if (gen === 'sidewinder') maze = GridMaze.generateSidewinder(n, n);
      else if (gen === 'eller') maze = GridMaze.generateEller(n, n);
      else if (gen === 'prim') maze = GridMaze.generatePrim(n, n);
      else if (gen === 'binary_tree') maze = GridMaze.generateBinaryTree(n, n);
      else if (gen === 'hunt_and_kill') maze = GridMaze.generateHuntAndKill(n, n);
      else if (gen === 'spine_branches') maze = GridMaze.generateSpineBranches(n, n);
      else maze = GridMaze.generateWilson(n, n);

      // recompute depth table for debug highlighting
      const root = maze.idx(0, 0);
      depthFromRoot = computeDepths(maze, root);
      updateLcaDebug();

      const count = Math.max(1, Math.min(30, Number(agentCountInput.value) || 1));
      createAgents(count, algoSelect.value);
    }

    btnGenerate.addEventListener("click", generateNewMaze);
    btnRestart.addEventListener("click", restartExploration);

    algoSelect.addEventListener("change", () => {
      // garder labyrinthe, mais changer algo => restart
      if (!maze) return;
      restartExploration();
    });

    document.getElementById("debugToggle").addEventListener("change", () => {
      const debugPanel = document.getElementById("debugPanel");
      if (debugPanel.classList.contains("visible")) {
        debugPanel.classList.remove("visible");
      } else {
        debugPanel.classList.add("visible");
      }
    });

    document.getElementById("chkShowLongestPath").addEventListener("change", (e) => {
      if (!maze) return;
      if (e.target.checked) {
        const root = maze.idx(0, 0);
        debugPath = findLongestPath(maze, root);
      } else {
        debugPath = null;
      }
      draw(canvas, maze, claimedBy, agents);
    });

    document.getElementById("chkHighlightDepth").addEventListener("change", () => {
      if (maze) draw(canvas, maze, claimedBy, agents);
    });
    document.getElementById("depthLevel").addEventListener("input", () => {
      if (maze) draw(canvas, maze, claimedBy, agents);
    });
    document.getElementById("chkShowFrontier").addEventListener("change", () => {
      if (maze) draw(canvas, maze, claimedBy, agents);
    });
    document.getElementById("chkShowAnchorCounts").addEventListener("change", () => {
      if (maze) draw(canvas, maze, claimedBy, agents);
    });
    if (lgaLambdaInput) {
      lgaLambdaInput.addEventListener("input", () => {
        // only affects LGA2 policy on next reanchor
      });
    }

    document.getElementById("chkShowLca").addEventListener("change", () => {
      if (!maze) return;
      updateLcaDebug();
      draw(canvas, maze, claimedBy, agents);
    });
    if (lcaUInput) {
      lcaUInput.addEventListener("input", () => {
        if (!maze) return;
        updateLcaDebug();
        draw(canvas, maze, claimedBy, agents);
      });
    }
    if (lcaVInput) {
      lcaVInput.addEventListener("input", () => {
        if (!maze) return;
        updateLcaDebug();
        draw(canvas, maze, claimedBy, agents);
      });
    }

    window.addEventListener("resize", () => {
      if (maze) draw(canvas, maze, claimedBy, agents);
    });

    // =========================
    // Loop simulation
    // =========================
    function allDone() {
      if (algoSelect.value === "cte") return cteShared?.allDone() ?? false;
      // sinon: considéré terminé quand toutes les cellules sont claim (global)
      return claimedCount >= claimedBy.length;
    }

    function tick(t) {
      const dt = Math.max(0, (t - lastT) / 1000);
      lastT = t;

      // update timer (dt is in seconds)
      if (timerRunning) {
        timerElapsed += dt * 1000;
      }

      // Throttle DOM updates for timer/moves/progress to reduce visual jitter
      if (t - lastUiUpdate >= 100) {
        lastUiUpdate = t;
        if (timerValEl) timerValEl.textContent = `${(timerElapsed / 1000).toFixed(2)} s`;

        // update exploration progress
        const progressEl = document.getElementById("progressVal");
        if (maze && progressEl) {
          const totalCells = maze.width * maze.height;
          const explorationPercent = Math.round((claimedCount / totalCells) * 100);
          progressEl.textContent = `${explorationPercent} %`;
        }

        // update moves counter
        const movesEl = document.getElementById("movesVal");
        if (movesEl) movesEl.textContent = `${movesCount} moves`;
      }

      if (maze && agents.length > 0 && !allDone()) {
        const maxStepsPerFramePerAgent = 2500;

        for (const a of agents) {
          if (a.done) continue;

          a.budget += dt * a.speed;
          const stepsToDo = Math.min(maxStepsPerFramePerAgent, Math.floor(a.budget));

          for (let k = 0; k < stepsToDo && !a.done; k++) {
            a.stepOnce();
          }

          a.budget -= stepsToDo;
        }
      }

      // if exploration completed, freeze timer
      if (maze && agents.length > 0 && allDone()) {
        timerRunning = false;
      }

      if (maze) {
        draw(canvas, maze, claimedBy, agents);
        updateAgentsStatusUI();
      }

      requestAnimationFrame(tick);
    }

    // init
    generateNewMaze();
    requestAnimationFrame(tick);
  </script>
</body>
</html>
